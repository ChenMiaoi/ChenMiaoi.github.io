<!DOCTYPE html>
<html lang="en,zh,default">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Chen Miao">





<title>rCore Ch3 Details | Nay&#39;s Blog</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
            <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    "HTML-CSS": {
        preferredFont: "TeX",
        availableFonts: ["STIX","TeX"],
        linebreaks: { automatic:true },
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ],
        processEscapes: true,
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
        Macros: { href: "{}" }
    },
    messageStyle: "none"
    });
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script>


        
    


<meta name="generator" content="Hexo 7.3.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Nayy&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Nayy&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">rCore Ch3 Details</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">Chen Miao</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">April 9, 2025&nbsp;&nbsp;20:29:21</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/rCore/">rCore</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="rCore-ch3-detail"><a href="#rCore-ch3-detail" class="headerlink" title="rCore ch3 detail"></a>rCore ch3 detail</h1><blockquote>
<p>本篇文章是帮助初学者加快理解rCore的设计原理的文章，并不设计任何关于opencamp实现相关。部分细节参考<a target="_blank" rel="noopener" href="https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter3/index.html#">rCore Tutorial Book chapter3</a> 和 <a target="_blank" rel="noopener" href="https://learningos.cn/rCore-Tutorial-Guide-2025S/chapter3/index.html">rCore Tutorial Guild chapter3</a>。<br>如有任何问题，请到对应仓库(<a target="_blank" rel="noopener" href="https://github.com/ChenMiaoi/ChenMiaoi.github.io/tree/hexo">nya blog repo</a>)下提出相关<code>issue</code>，参见格式：[Book Name]: Question</p>
</blockquote>
<ul>
<li>Reference<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/riscv/riscv-isa-manual/releases/download/riscv-isa-release-8696121-2025-04-04/riscv-unprivileged.pdf">RISC-V ISA MANUAL UNPRIVILEGE</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/riscv/riscv-isa-manual/releases/download/riscv-isa-release-8696121-2025-04-04/riscv-privileged.pdf">RISC-V ISA MANUAL PRIVILEGE</a></li>
</ul>
</li>
</ul>
<hr>
<p>下面，我会以我们实际阅读代码的角度来依次分析rCore的具体实现细节，当然部分简单机制会被忽略。</p>
<p>在开始分析rCore操作系统的具体实现时，我们首先需要确保开发环境的正确性。通过执行以下命令切换到ch3分支并验证其可运行性：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout ch3</span><br><span class="line"><span class="built_in">cd</span> os; make run</span><br></pre></td></tr></table></figure>

<p>面对复杂的操作系统实现，合理的分析顺序能显著提高理解效率。在rCore项目中，我建议采用以下分析路径：</p>
<ol>
<li>构建系统分析(<a href="">os&#x2F;Makefile</a>)</li>
<li>用户程序分析(<a href="">user&#x2F;src&#x2F;lib.rs</a>)</li>
<li>内核入口分析(<a href="">os&#x2F;src&#x2F;main.rs</a>)</li>
</ol>
<p>构建系统是理解整个项目的关键入口。我们重点分析<code>os/Makefile</code>中<code>make run</code>的执行流程：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">build: <span class="variable">$(KERNEL_BIN)</span></span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(KERNEL_BIN)</span>: kernel</span><br><span class="line">	@<span class="variable">$(OBJCOPY)</span> <span class="variable">$(KERNEL_ELF)</span> --strip-all -O binary <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">kernel:</span></span><br><span class="line">	@make -C ../user build TEST=<span class="variable">$(TEST)</span> CHAPTER=<span class="variable">$(CHAPTER)</span> BASE=<span class="variable">$(BASE)</span></span><br><span class="line">	@echo Platform: <span class="variable">$(BOARD)</span></span><br><span class="line">	@cargo build <span class="variable">$(MODE_ARG)</span></span><br><span class="line"></span><br><span class="line"><span class="section">run: run-inner</span></span><br><span class="line"></span><br><span class="line"><span class="section">run-inner: build</span></span><br><span class="line">	@qemu-system-riscv64 \</span><br><span class="line">		-machine virt \</span><br><span class="line">		-nographic \</span><br><span class="line">		-bios <span class="variable">$(BOOTLOADER)</span> \</span><br><span class="line">		-device loader,file=<span class="variable">$(KERNEL_BIN)</span>,addr=<span class="variable">$(KERNEL_ENTRY_PA)</span></span><br></pre></td></tr></table></figure>

<p>在<code>os/Makefile</code>中，<code>make run</code>依赖于<code>build</code>，而<code>build</code>会依赖于<code>kernel</code>，在<code>kernel</code>中，会做两件事情：</p>
<ol>
<li>编译出<code>os</code>中需要的应用程序，用来验证我们的多道程序操作系统</li>
<li>编译出<code>os</code>可执行文件，或者说内核镜像文件，用于启动我们的内核</li>
</ol>
<p>因此，我们现在讲目光跳转到<code>user</code>中。</p>
<h2 id="User"><a href="#User" class="headerlink" title="User"></a>User</h2><p>进入<code>user</code>目录后，我们首先也需要讲目光放在<code>user/Makefile</code>身上，其中，我们主要关注两个点：</p>
<ol>
<li>内核需要的<code>binary</code>是如何产出的</li>
<li><code>binary</code>的内存布局是如何的</li>
</ol>
<p>对于上述的两个重点，在下面会被同时涉及到：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">binary:</span></span><br><span class="line">	@echo <span class="variable">$(ELFS)</span></span><br><span class="line">	@if [ $&#123;CHAPTER&#125; -gt 3 ]; then \</span><br><span class="line">		cargo build <span class="variable">$(MODE_ARG)</span> ;\</span><br><span class="line">	<span class="keyword">else</span> \</span><br><span class="line">		CHAPTER=<span class="variable">$(CHAPTER)</span> python3 build.py ;\</span><br><span class="line">	fi</span><br><span class="line">	@<span class="variable">$(<span class="built_in">foreach</span> elf, <span class="variable">$(ELFS)</span>, \</span></span><br><span class="line"><span class="variable">		<span class="variable">$(OBJCOPY)</span> <span class="variable">$(elf)</span> --<span class="built_in">strip</span>-all -O binary $(<span class="built_in">patsubst</span> <span class="variable">$(TARGET_DIR)</span>/%, <span class="variable">$(TARGET_DIR)</span>/%.bin, <span class="variable">$(elf)</span>)</span>; \</span><br><span class="line">		cp <span class="variable">$(elf)</span> <span class="variable">$(<span class="built_in">patsubst</span> <span class="variable">$(TARGET_DIR)</span>/%, <span class="variable">$(TARGET_DIR)</span>/%.elf, <span class="variable">$(elf)</span>)</span>;)</span><br></pre></td></tr></table></figure>

<p>在<code>chapter3</code>中会调用一个<code>build.py</code>脚本进行具体的操作：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">base_address = <span class="number">0x80400000</span></span><br><span class="line">step = <span class="number">0x20000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> app <span class="keyword">in</span> apps:</span><br><span class="line">  os.system(</span><br><span class="line">    <span class="string">&quot;cargo rustc --bin %s %s -- -Clink-args=-Ttext=%x&quot;</span></span><br><span class="line">    % (app, mode_arg, base_address + step * app_id)</span><br><span class="line">  )</span><br><span class="line">  <span class="keyword">if</span> chapter == <span class="string">&#x27;3&#x27;</span>:</span><br><span class="line">    app_id = app_id + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>在该构建脚本中，关键点在于 app_id 会随着应用程序的生成而递增，从而确保每个编译出的用户程序的起始地址（.text.entry 段）均不相同。这一机制与 chapter2 的实现形成鲜明对比，后者采用固定地址加载方式，而当前方案通过动态计算 base_address + step * app_id 来分配入口地址，确保不同应用程序在内存中的执行位置相互隔离。</p>
<p>接下来，我们需要关注 user&#x2F;src&#x2F;lib.rs 文件，其中定义了用户程序的入口逻辑。该文件包含两个关键部分：</p>
<p>​1. ​_start 函数​​：作为用户程序的初始入口点，由链接脚本显式定位到 .text.entry 段，负责初始化环境并调用 main 函数。<br>​​2. 弱符号 main 函数​​（#[linkage &#x3D; “weak”]）：通过弱符号机制允许不同用户程序提供自己的 main 实现，而链接器会在加载时解析到正确的版本。这种设计实现了入口点的统一管理，同时支持不同应用程序的灵活逻辑。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="meta">#[link_section = <span class="string">&quot;.text.entry&quot;</span>]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="keyword">fn</span> <span class="title function_">_start</span>(argc: <span class="type">usize</span>, argv: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="title function_ invoke__">clear_bss</span>();</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        HEAP.<span class="title function_ invoke__">lock</span>()</span><br><span class="line">            .<span class="title function_ invoke__">init</span>(HEAP_SPACE.<span class="title function_ invoke__">as_ptr</span>() <span class="keyword">as</span> <span class="type">usize</span>, USER_HEAP_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span>: <span class="type">Vec</span>&lt;&amp;<span class="symbol">&#x27;static</span> <span class="type">str</span>&gt; = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..argc &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">str_start</span> =</span><br><span class="line">            <span class="keyword">unsafe</span> &#123; ((argv + i * core::mem::size_of::&lt;<span class="type">usize</span>&gt;()) <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">usize</span>).<span class="title function_ invoke__">read_volatile</span>() &#125;;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">len</span> = (<span class="number">0usize</span>..)</span><br><span class="line">            .<span class="title function_ invoke__">find</span>(|i| <span class="keyword">unsafe</span> &#123; ((str_start + *i) <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">u8</span>).<span class="title function_ invoke__">read_volatile</span>() == <span class="number">0</span> &#125;)</span><br><span class="line">            .<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        v.<span class="title function_ invoke__">push</span>(</span><br><span class="line">            core::<span class="type">str</span>::<span class="title function_ invoke__">from_utf8</span>(<span class="keyword">unsafe</span> &#123;</span><br><span class="line">                core::slice::<span class="title function_ invoke__">from_raw_parts</span>(str_start <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">u8</span>, len)</span><br><span class="line">            &#125;)</span><br><span class="line">            .<span class="title function_ invoke__">unwrap</span>(),</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">exit</span>(<span class="title function_ invoke__">main</span>(argc, v.<span class="title function_ invoke__">as_slice</span>()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[linkage = <span class="string">&quot;weak&quot;</span>]</span></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>(_argc: <span class="type">usize</span>, _argv: &amp;[&amp;<span class="type">str</span>]) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">&quot;Cannot find main!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在用户程序构建过程中，<code>_start</code>函数被显式地定位到<code>src/linker.ld</code>链接脚本中定义的<code>.text.entry</code>段，该段作为用户程序的入口点。通过<code>build.py</code>编译脚本的配置，<code>.text.entry</code>段的起始地址被动态计算为<code>base_address + step * app_id</code>，其中<code>base_address</code>是基地址，<code>step</code>为地址间隔，<code>app_id</code>为应用程序标识符。这种地址分配机制确保了不同用户程序被载入内核后，其入口点位于互不重叠的独立内存区域，从而避免执行地址冲突。</p>
<p>在程序执行流程中，<code>_start</code>函数会进一步调用<code>exit(main(argc, v.as_slice()))</code>。此处引用的main函数被声明为弱符号(<code>weak symbol</code>)，这种设计允许在链接阶段存在多个<code>main</code>函数定义。最终链接器会根据实际加载的用户程序选择对应的<code>main</code>函数实现，从而实现多态入口机制。该架构既保持了入口点的统一性，又支持不同用户程序拥有独立的业务逻辑入口。</p>
<p>至此，用户态程序的准备工作已全部完成，其核心机制可总结如下：  </p>
<ul>
<li>动态基址分配​​</li>
<li>剥离 ELF 信息的二进制文件​​<ul>
<li>编译生成的用户程序被处理为纯二进制文件（binary），移除了 ELF 格式的元数据（如节头表、符号表等），仅保留可执行代码和数据。  </li>
<li>内核可直接加载这些轻量化的二进制文件，无需解析复杂 ELF 结构，提升了运行效率。</li>
</ul>
</li>
<li>标准化入口与弱符号机制​​</li>
</ul>
<h2 id="Kernel"><a href="#Kernel" class="headerlink" title="Kernel"></a>Kernel</h2><p>在 rCore 操作系统的构建流程中，用户程序的编译与内核镜像的生成遵循严格的自动化构建策略。当用户程序完成编译后，os&#x2F;Makefile 会立即触发 cargo build 命令以生成最终的内核镜像。</p>
<p>为确保用户程序能够正确嵌入内核并建立可执行环境，rCore 在编译前通过 ​​构建脚本（os&#x2F;build.rs）​​ 执行关键配置操作：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">f</span> = File::<span class="title function_ invoke__">create</span>(<span class="string">&quot;src/link_app.S&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>在 rCore 操作系统的构建过程中，os&#x2F;build.rs 脚本会在编译阶段动态生成 os&#x2F;src&#x2F;link_app.S 汇编文件，其结构如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">    .align 3</span><br><span class="line">    .section .data</span><br><span class="line">    .global _num_app</span><br><span class="line">_num_app:</span><br><span class="line">    .quad 2</span><br><span class="line">    .quad app_0_start</span><br><span class="line">    .quad app_1_start</span><br><span class="line">    .quad app_1_end</span><br><span class="line"></span><br><span class="line">    .section .data</span><br><span class="line">    .global app_0_start</span><br><span class="line">    .global app_0_end</span><br><span class="line">app_0_start:</span><br><span class="line">    .incbin &quot;../user/build/bin/xxx.bin&quot;</span><br><span class="line">app_0_end:</span><br><span class="line"></span><br><span class="line">    .section .data</span><br><span class="line">    .global app_1_start</span><br><span class="line">    .global app_1_end</span><br><span class="line">app_1_start:</span><br><span class="line">    .incbin &quot;../user/build/bin/yyy.bin&quot;</span><br><span class="line">app_1_end:</span><br></pre></td></tr></table></figure>

<p>在完成用户程序的静态嵌入与内核镜像的构建后，系统已具备启动条件。但在正式运行内核之前，需深入理解以下关键模块的设计与协作机制。</p>
<h3 id="Load-Task"><a href="#Load-Task" class="headerlink" title="Load &amp; Task"></a>Load &amp; Task</h3><p>在操作系统的设计与实现中，每个任务（Task）、程序（Program）或进程（Process）均需通过一个核心数据结构来维护其执行状态和上下文信息。以传统操作系统理论中的进程控制块（Process Control Block, PCB）为参照，rCore操作系统采用了任务控制块（Task Control Block, TCB）这一抽象结构，用于集中管理应用程序的元数据、资源描述符、执行上下文以及调度相关属性，从而实现对任务生命周期的全流程管控：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">TaskStatus</span> &#123;</span><br><span class="line">    <span class="comment">/// uninitialized</span></span><br><span class="line">    UnInit,</span><br><span class="line">    <span class="comment">/// ready to run</span></span><br><span class="line">    Ready,</span><br><span class="line">    <span class="comment">/// running</span></span><br><span class="line">    Running,</span><br><span class="line">    <span class="comment">/// exited</span></span><br><span class="line">    Exited,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">TaskControlBlock</span> &#123;</span><br><span class="line">    <span class="comment">/// The task status in it&#x27;s lifecycle</span></span><br><span class="line">    <span class="keyword">pub</span> task_status: TaskStatus,</span><br><span class="line">    <span class="comment">/// The task context</span></span><br><span class="line">    <span class="keyword">pub</span> task_cx: TaskContext,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在操作系统的多任务管理机制中，单个 ​​任务控制块（Task Control Block, TCB）​​ 仅能维护一个任务的执行视图。为了全局管理所有任务的调度与状态，rCore 引入了 ​​任务管理器（TaskManager）​​ 作为顶层抽象，负责维护系统中所有 TCB 的集合。</p>
<p>然而，在多任务并发环境下，直接访问 TCB 可能导致数据竞争或状态不一致问题。为此，rCore 采用 ​​内部封装（TaskManagerInner）​​ 的设计模式，将核心任务管理逻辑（如任务调度、状态切换、资源分配等）封装在受保护的内部结构中，并通过 ​​同步原语（如互斥锁或原子操作）​​ 确保线程安全。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">TaskManager</span> &#123;</span><br><span class="line">    <span class="comment">/// total number of tasks</span></span><br><span class="line">    num_app: <span class="type">usize</span>,</span><br><span class="line">    <span class="comment">/// use inner value to get mutable access</span></span><br><span class="line">    inner: UPSafeCell&lt;TaskManagerInner&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Inner of Task Manager</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">TaskManagerInner</span> &#123;</span><br><span class="line">    <span class="comment">/// task list</span></span><br><span class="line">    tasks: [TaskControlBlock; MAX_APP_NUM],</span><br><span class="line">    <span class="comment">/// id of current `Running` task</span></span><br><span class="line">    current_task: <span class="type">usize</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在介绍更多之前，我们还需要了解一下任务上下文。在操作系统的任务调度机制中，​​任务上下文（Task Context）​​ 是实现多任务并发的核心抽象，其本质是任务执行状态的快照，用于在任务切换时保存和恢复关键寄存器状态。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pub struct TaskContext &#123;</span><br><span class="line">    /// Ret position after task switching</span><br><span class="line">    ra: usize,</span><br><span class="line">    /// Stack pointer</span><br><span class="line">    sp: usize,</span><br><span class="line">    /// s0-11 register, callee saved</span><br><span class="line">    s: [usize; 12],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>ra(return address)</code>：保存任务切换后应跳转的指令地址（如 __restore 或用户程序入口）。在上下文切换时，CPU 通过 ret 指令返回到 ra 指向的地址，实现执行流的无缝衔接。</li>
<li><code>sp(stack pointer)</code>：维护任务的独立栈空间。每个任务需拥有专属内核栈（或用户栈），sp 确保切换后能正确访问局部变量和函数调用链。</li>
<li><code>sn(callee-saved register)</code>：RISC-V 规定这些寄存器由被调用函数（Callee）保存。任务切换时需手动保存它们，避免破坏任务自身的计算状态（如循环变量、指针等）。</li>
</ul>
<p>接下来我们就可以继续分析内核的执行：在rCore操作系统初始启动阶段，系统通过lazy_static宏实现了TASK_MANAGER全局变量的惰性初始化。对于每个用户任务，内核会调用goto_restore(init_app_cx(i))函数进行上下文初始化：其中init_app_cx(i)负责在内核栈中构建指定任务的初始执行上下文，其返回值作为该任务的内核栈指针；而goto_restore则将该任务的返回地址设置为__restore符号地址，从而建立从内核态到用户态的正确执行流切换路径。</p>
<p>在任务管理初始化完成后，系统通过load_apps函数加载所有用户程序到物理内存。这些用户程序的加载地址严格遵循build.py构建脚本中预设的入口地址配置，确保用户态程序的二进制映像被精确映射到预期的内存区域，为后续的任务执行建立正确的地址空间布局。</p>
<p>此时，我们还需要一个能够切换任务上下文的函数，因此使用<code>switch.S</code>来实现：</p>
<ol>
<li>保存当前任务的<code>sp</code></li>
<li>保存当前任务的<code>ra</code></li>
<li>保存当前任务的<code>sn</code></li>
<li>载入下一个任务的<code>ra</code></li>
<li>载入下一个任务的<code>sn</code></li>
<li>载入下一个任务的<code>sp</code></li>
<li>最后通过<code>ret</code>指令返回到<code>ra</code>(即<code>__restore</code>)指向的地址处继续执行</li>
</ol>
<p>值得注意的是：<code>__switch</code><strong>只处理内核栈和寄存器的保存与回复，不会涉及用户态的回复和特权级切换，因此需要转入<code>__restore</code>中继续执行</strong>。</p>
<p>因从，我们继续分析 <code>run_first_task</code>的全流程会发生什么。<code>run_first_task</code>会取出第一个任务，然后与一个空任务进行交换：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__switch(&amp;<span class="keyword">mut</span> _unused <span class="keyword">as</span> *<span class="keyword">mut</span> TaskContext, next_task_cx_ptr);</span><br></pre></td></tr></table></figure>

<p>此时，<code>__switch</code>会载入第一个任务的栈和指针，并将<code>ra(__restore)</code>载入，通过<code>ret</code>进入到<code>__restore</code>入口。在Load阶段有一点没有说明的是：</p>
<p><strong>每一个任务在初始化上下文时，都需要载入以下数据</strong>：</p>
<ul>
<li><strong>寄存器值</strong></li>
<li><strong>sstatus寄存器(设置为User模式)</strong></li>
<li><strong>sepc寄存器(设置为用户程序的入口点)</strong></li>
<li><strong>sp寄存器(用户栈指针，x[2])</strong></li>
</ul>
<p>通过查阅<a href="">RISC-V ISA PREVILEGE Supervisor-Level ISA</a>可以了解到：</p>
<ul>
<li><strong>sstatus</strong>寄存器用于恢复CPU特权级状态（例如重新允许中断、切换回用户态）</li>
<li><strong>sepc</strong>寄存器用于设定<code>sret</code>指令的返回地址（即返回到用户程序的哪条指令）。</li>
<li><strong>sscratch</strong>寄存器用于保存用户栈指针，用于后续交换栈指针。</li>
</ul>
<p>并且，<strong>在<code>init_app_cx</code>函数中我们将每一个任务的上下文地址压入了内核栈中</strong>:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">KERNEL_STACK[app_id].<span class="title function_ invoke__">push_context</span>(TrapContext::<span class="title function_ invoke__">app_init_context</span>(</span><br><span class="line">    <span class="title function_ invoke__">get_base_i</span>(app_id),</span><br><span class="line">    USER_STACK[app_id].<span class="title function_ invoke__">get_sp</span>(),</span><br><span class="line">))</span><br></pre></td></tr></table></figure>

<p>因此，这里就有了一个很清晰的对于用户栈和内核栈的概念了：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TaskContext</span><br><span class="line">    |--&gt; ra -&gt; __restore</span><br><span class="line">    |--&gt; sp -&gt; kstack --&gt; TrapContext</span><br><span class="line">    ---&gt; sn                   |--&gt; xn</span><br><span class="line">                              |--&gt; sstatus-&gt; User Mode</span><br><span class="line">                              |--&gt; sepc   -&gt; User Task Base Entry</span><br><span class="line">                              |              (APP_BASE_ADDRESS + app_id * APP_SIZE_LIMIT)</span><br><span class="line">                              ---&gt; sp(x2) -&gt; user stack</span><br></pre></td></tr></table></figure>

<p><img src="https://hexo-pirctures.oss-cn-chengdu.aliyuncs.com/20250409203607718.png" alt="__switch"></p>
<p>现在我们重新看回<code>run_first_task</code>的流程，当我们执行到<code>__restore</code>时，我们直接载入第一个任务的<code>sstatus</code>、<code>sepc</code>和<code>sp</code>指针：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ld t0, 32*8(sp)</span><br><span class="line">ld t1, 33*8(sp)</span><br><span class="line">ld t2, 2*8(sp)</span><br><span class="line">csrw sstatus, t0</span><br><span class="line">csrw sepc, t1</span><br><span class="line">csrw sscratch, t2</span><br></pre></td></tr></table></figure>

<p>此时，操作系统已经知道了<code>sret</code>要返回的用户程序入口以及用户程序的栈，然后再载入其他寄存器到操作系统中(<strong>注意，此时的<code>sp</code>还是指向的内核栈</strong>)；载入成功后，<strong>我们需要将内核指针移动$34*8$个字节</strong>(<code>sizeof TrapContex</code>)，然后再通过<code>csrrw</code>交换内核栈和用户栈(此时<code>sscratch -&gt; kstack, sp -&gt; user stack</code>)。</p>
<p>最后，我们通过<code>sret</code>进入到第一个用户程序的入口点，便可以开始执行了。</p>
<p>在系统实现层面，部分开发者可能对任务调度机制存在疑问：<strong>为何仅调用<code>run_first_task</code>函数即可完成所有应用程序的执行流程。虽然直觉上可能联想到<code>trap</code>中断机制的作用，但在分析<code>hello_world</code>这类无显式异常触发的用例时仍会产生困惑</strong>。需要特别说明的是，当前内核采用了一种精简的设计架构，其任务调度必然依赖<code>trap</code>异常处理机制实现——具体而言，内核在异常处理例程中隐式地执行了任务上下文保存与切换操作，从而实现了多任务的轮转调度。这种设计使得用户态程序无需主动触发异常即可被系统透明地管理，体现了中断驱动式调度（interrupt-driven scheduling）的典型特征。</p>
<h3 id="Trap"><a href="#Trap" class="headerlink" title="Trap"></a>Trap</h3><p>对于<code>rCore</code>的<code>trap</code>机制，个人认为<a target="_blank" rel="noopener" href="https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter2/4trap-handling.html#trap">rCore trap</a>讲的比较详细，便不再过于赘述。可以给出一些<code>debug</code>图例仅供参考。</p>
<p><img src="https://hexo-pirctures.oss-cn-chengdu.aliyuncs.com/20250409204246034.png" alt="__switch ra &amp; sp"></p>
<p>上图是关于<code>__switch</code>函数中的<code>ra</code>和<code>sp</code>地址的查看。</p>
<p><img src="https://hexo-pirctures.oss-cn-chengdu.aliyuncs.com/20250409204347288.png" alt="__restore sp"></p>
<p>上图是关于<code>__restore</code>函数中的<code>kstack</code>地址的查看。</p>
<p><img src="https://hexo-pirctures.oss-cn-chengdu.aliyuncs.com/20250409204458874.png" alt="__restore user sp"></p>
<p>上图是关于<code>__restore</code>函数中的<code>user stack</code>地址的查看。</p>
<h3 id="Syscall"><a href="#Syscall" class="headerlink" title="Syscall"></a>Syscall</h3><p>对于操作系统来说，系统调用是一件十分简单的事情(如果你已经搞明白了<code>trap</code>机制的原理)，系统调用本质上就是个精心设计的陷阱(trap)。当你理解了<code>ecall</code>这个魔法指令，实现系统调用就像搭积木一样简单。：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">syscall</span>(id: <span class="type">usize</span>, args: [<span class="type">usize</span>; <span class="number">3</span>]) <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">ret</span>: <span class="type">isize</span>;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        core::arch::asm!(</span><br><span class="line">            <span class="string">&quot;ecall&quot;</span>,</span><br><span class="line">            <span class="title function_ invoke__">inlateout</span>(<span class="string">&quot;x10&quot;</span>) args[<span class="number">0</span>] =&gt; ret,</span><br><span class="line">            <span class="title function_ invoke__">in</span>(<span class="string">&quot;x11&quot;</span>) args[<span class="number">1</span>],</span><br><span class="line">            <span class="title function_ invoke__">in</span>(<span class="string">&quot;x12&quot;</span>) args[<span class="number">2</span>],</span><br><span class="line">            <span class="title function_ invoke__">in</span>(<span class="string">&quot;x17&quot;</span>) id</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，如果你了解过<code>xv6-riscv</code>的话，系统调用也不在话下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.globl start</span><br><span class="line">start:</span><br><span class="line">    la a0, init</span><br><span class="line">    la a1, argv</span><br><span class="line">    li a7, SYS_exec</span><br><span class="line">    ecall</span><br></pre></td></tr></table></figure>

<p>现在我们回到上面没有解决的问题：<strong>为什么类似于<code>hello_world</code>的应用程序能够自动的切换为下一个应用程序呢</strong>？</p>
<p>我们需要回忆起：我们在编译出应用程序的<code>binary</code>时，使用的<code>weak main</code>，因此，当我们执行到应用程序的<code>_start</code>入口时可以发现：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[link_section = <span class="string">&quot;.text.entry&quot;</span>]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="keyword">fn</span> <span class="title function_">_start</span>(argc: <span class="type">usize</span>, argv: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">  <span class="title function_ invoke__">exit</span>(<span class="title function_ invoke__">main</span>(argc, v.<span class="title function_ invoke__">as_slice</span>()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">exit</span>(exit_code: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">  console::<span class="title function_ invoke__">flush</span>();</span><br><span class="line">  <span class="title function_ invoke__">sys_exit</span>(exit_code);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的<code>main</code>调用居然包裹了一个<code>exit</code>调用，而这个<code>exit</code>调用正是一个系统调用<code>sys_exit</code>，因此，当<code>hello_world</code>执行完毕之后，会因为系统调用而进入<code>trap_handler</code>从而切换了下一个应用程序：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">exit_current_and_run_next</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">mark_current_exited</span>();</span><br><span class="line">    <span class="title function_ invoke__">run_next_task</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Trap::<span class="title function_ invoke__">Exception</span>(Exception::UserEnvCall) =&gt; &#123;</span><br><span class="line">    <span class="comment">// jump to next instruction anyway</span></span><br><span class="line">    cx.sepc += <span class="number">4</span>;</span><br><span class="line">    <span class="comment">// get system call return value</span></span><br><span class="line">    cx.x[<span class="number">10</span>] = <span class="title function_ invoke__">syscall</span>(cx.x[<span class="number">17</span>], [cx.x[<span class="number">10</span>], cx.x[<span class="number">11</span>], cx.x[<span class="number">12</span>]]) <span class="keyword">as</span> <span class="type">usize</span>;</span><br><span class="line">&#125;</span><br><span class="line">Trap::<span class="title function_ invoke__">Exception</span>(Exception::StoreFault) | Trap::<span class="title function_ invoke__">Exception</span>(Exception::StorePageFault) =&gt; &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;[kernel] PageFault in application, bad addr = &#123;:#x&#125;, bad instruction = &#123;:#x&#125;, kernel killed it.&quot;</span>, stval, cx.sepc);</span><br><span class="line">    <span class="title function_ invoke__">exit_current_and_run_next</span>();</span><br><span class="line">&#125;</span><br><span class="line">Trap::<span class="title function_ invoke__">Exception</span>(Exception::IllegalInstruction) =&gt; &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;[kernel] IllegalInstruction in application, kernel killed it.&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">exit_current_and_run_next</span>();</span><br><span class="line">&#125;</span><br><span class="line">Trap::<span class="title function_ invoke__">Interrupt</span>(Interrupt::SupervisorTimer) =&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">set_next_trigger</span>();</span><br><span class="line">    <span class="title function_ invoke__">suspend_current_and_run_next</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，<code>rCore</code>的第三章实现流程便分析完毕了。</p>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>Chen Miao</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="https://chenmiaoi.github.io/2025/04/09/rCore-ch3-Details/">https://chenmiaoi.github.io/2025/04/09/rCore-ch3-Details/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2024 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>Do you believe in <strong>DESTINY</strong>?</span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/os/"># os</a>
                    
                        <a href="/tags/riscv/"># riscv</a>
                    
                        <a href="/tags/rCore/"># rCore</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2025/06/15/GSOC2025-How-To-Start-With-OpenRISC/">GSOC2025: How to Start With OpenRISC</a>
            
            
            <a class="next" rel="next" href="/2025/02/15/STL17-New-Features/">STL17: New Features</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Chen Miao | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>