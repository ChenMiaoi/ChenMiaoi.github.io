<!DOCTYPE html>
<html lang="en,zh,default">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Chen Miao">





<title>LevelDB: A Whole Open Operation | Nay&#39;s Blog</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
            <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    "HTML-CSS": {
        preferredFont: "TeX",
        availableFonts: ["STIX","TeX"],
        linebreaks: { automatic:true },
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ],
        processEscapes: true,
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
        Macros: { href: "{}" }
    },
    messageStyle: "none"
    });
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script>


        
    


<meta name="generator" content="Hexo 7.3.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Nayy&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Nayy&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">LevelDB: A Whole Open Operation</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">Chen Miao</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">September 16, 2024&nbsp;&nbsp;22:17:21</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/leveldb/">leveldb</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="LevelDB-A-whole-Open-Operation"><a href="#LevelDB-A-whole-Open-Operation" class="headerlink" title="LevelDB: A whole Open Operation"></a>LevelDB: A whole Open Operation</h1><p><em>我在最近接触了分布式存储计算这一个方向，因此想从leveldb作为一个最初的学习项目；起初，我是通过<a target="_blank" rel="noopener" href="https://hardcore.feishu.cn/mindnotes/bmncnzpUmXNQruVGOwRwisHyxoh">硬核课堂 LevelDB源码分析</a>这一飞书文档学习，但是这个文档有些学习顺序我个人不是很习惯，因此打算分模块去将整个LevelDB的整个源码细节</em>。</p>
<p><em>首先第一个模块，便是<code>DB::Open</code>这一操作</em>。我们需要分析<code>Open</code>的操作，就首先需要从一个宏观的角度分析<code>Open</code>会做出什么操作。</p>
<p>**<code>DB::Open</code>是用于打开一个数据库的核心函数。它的主要任务是<code>初始化数据库</code>、<code>加载数据库元数据</code>、恢复&#x2F;修复数据库数据<code>并</code>确保数据库处于可用状态&#96;**。</p>
<p>我们首先从宏观角度来观察<code>DB::Open</code>的实现具体做了些什么：</p>
<ul>
<li>第一步：初始化</li>
</ul>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DB::Open</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> Options&amp; options, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> std::string&amp; dbname, </span></span></span><br><span class="line"><span class="params"><span class="function">    DB** dbptr)</span> </span>&#123;</span><br><span class="line">    *dbptr = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Open</code>函数会在一开始就将想要返回的<code>db</code>句柄设置为<code>nullptr</code>这是为了确保<strong>函数执行过程中，一旦出现任何问题，<code>dbptr</code>就会保持为<code>nullptr</code>，表示数据库打开失败</strong>。</p>
<ul>
<li>第二步：创建<code>DBImpl</code>数据库实例</li>
</ul>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DBImpl* impl = <span class="keyword">new</span> <span class="built_in">DBImpl</span>(options, dbname);</span><br><span class="line">impl-&gt;mutex_.<span class="built_in">Lock</span>();</span><br></pre></td></tr></table></figure>

<p><code>DBImpl</code>是<code>DB</code>的内部接口，<code>DBImpl</code>是实际上的操作接口，这一点会在后面详细介绍。然后我们需要保证数据库的操作在多线程环境下是安全的，因此对<code>DBImpl::mutex_</code>进行上锁。</p>
<ul>
<li>第三步：恢复操作的初始化</li>
</ul>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">VersionEdit edit;</span><br><span class="line"><span class="type">bool</span> save_manifest = <span class="literal">false</span>;</span><br><span class="line">Status s = impl-&gt;<span class="built_in">Recover</span>(&amp;edit, &amp;save_manifest);</span><br></pre></td></tr></table></figure>

<p>在<code>LevelDB</code>中，<code>VersionEdit</code>的<strong>主要作用是记录数据库版本的更改。具体来说，它用于描述数据库的元数据变更，如文件的添加、删除以及日志编号的更新。这些更改会被写入 <code>MANIFEST</code> 文件中，以确保数据库的状态在系统重启或恢复时能够一致且可靠地重建</strong>。</p>
<p><code>save_manifest</code>用于标识是否需要更新 <code>MANIFEST</code> 文件，而<code>Recover</code>函数负责处理数据库的恢复，<strong>确保数据库处于一致的状态</strong>，并根据选项<code>create_if_missing</code>和<code>error_if_exists</code>来决定是否创建或报告错误。</p>
<ul>
<li>第四步：创建MemTable和对应的日志文件</li>
</ul>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s.<span class="built_in">ok</span>() &amp;&amp; impl-&gt;mem_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">  <span class="type">uint64_t</span> new_log_number = impl-&gt;versions_-&gt;<span class="built_in">NewFileNumber</span>();</span><br><span class="line">  WritableFile* lfile;</span><br><span class="line">  s = options.env-&gt;<span class="built_in">NewWritableFile</span>(<span class="built_in">LogFileName</span>(dbname, new_log_number), &amp;lfile);</span><br><span class="line">  <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    edit.<span class="built_in">SetLogNumber</span>(new_log_number);</span><br><span class="line">    impl-&gt;logfile_ = lfile;</span><br><span class="line">    impl-&gt;logfile_number_ = new_log_number;</span><br><span class="line">    impl-&gt;log_ = <span class="keyword">new</span> log::<span class="built_in">Writer</span>(lfile);</span><br><span class="line">    impl-&gt;mem_ = <span class="keyword">new</span> <span class="built_in">MemTable</span>(impl-&gt;internal_comparator_);</span><br><span class="line">    impl-&gt;mem_-&gt;<span class="built_in">Ref</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>LevelDB</code>中，<code>MemTable</code>是一个核心的数据结构，<strong>它用于暂时存储写入操作的数据，并在合适的时机将其写入磁盘。<code>MemTable</code>是一个内存中的<code>跳表(skip list)</code>，支持高效的插入、查询、和删除操作</strong>。</p>
<ul>
<li><strong>当数据被写入 LevelDB 时，首先会写入到 MemTable 中，而不是直接写入磁盘。这是为了避免频繁的磁盘 I&#x2F;O，提升写入性能</strong>。</li>
<li><strong>写入到 MemTable 的数据也会被同时记录在一个日志文件（WAL，Write-Ahead Log）中，以确保在崩溃时可以通过日志文件恢复未写入磁盘的数据</strong>.</li>
</ul>
<p>如果在第三步时的<code>Recover</code>操作正常进行，并且此时需要打开的数据库中没有相应的<code>MemTable</code>，那么就应该创建新的日志文件和一块新的<code>MemTable</code>用于记录操作和存储内存中的数据，稍后通过<code>MemTable</code>写入到磁盘中。</p>
<ul>
<li>第五步：保存<code>MANIFEST</code>文件</li>
</ul>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s.<span class="built_in">ok</span>() &amp;&amp; save_manifest) &#123;</span><br><span class="line">  edit.<span class="built_in">SetPrevLogNumber</span>(<span class="number">0</span>);</span><br><span class="line">  edit.<span class="built_in">SetLogNumber</span>(impl-&gt;logfile_number_);</span><br><span class="line">  s = impl-&gt;versions_-&gt;<span class="built_in">LogAndApply</span>(&amp;edit, &amp;impl-&gt;mutex_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果恢复过程中需要保存 <code>MANIFEST</code> 文件，函数会更新新的日志文件编号，并通过 <code>LogAndApply</code> 应用这些更改。</p>
<ul>
<li>第六步：清理与压缩</li>
</ul>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">  impl-&gt;<span class="built_in">RemoveObsoleteFiles</span>();</span><br><span class="line">  impl-&gt;<span class="built_in">MaybeScheduleCompaction</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果一切仍然成功，函数将删除无用的文件（例如旧日志文件），并根据需要安排一次压缩操作。压缩操作可以减少数据库大小并提升性能。</p>
<ul>
<li>第七步：返回DB句柄</li>
</ul>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">impl-&gt;mutex_.<span class="built_in">Unlock</span>();</span><br><span class="line"><span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">  <span class="built_in">assert</span>(impl-&gt;mem_ != <span class="literal">nullptr</span>);</span><br><span class="line">  *dbptr = impl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">delete</span> impl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s;</span><br></pre></td></tr></table></figure>

<p>在这里，我们从宏观角度的视角了解了<code>DB::Open</code>的操作，以及其对应的作用，现在我们需要更细节的将整个<code>Open</code>的操作进行解构。</p>
<h2 id="Options"><a href="#Options" class="headerlink" title="Options"></a>Options</h2><p><code>Options</code>主要<strong>用于配置和控制数据库的行为，包括读写性能、资源使用、压缩策略等方面。<code>Options</code>类包含多种配置选项，允许用户在创建和使用数据库时根据具体需求进行定制</strong>。</p>
<p>对于<code>LevelDB::Options</code>而言，在整个数据库中有三种类型的<code>Options</code>：</p>
<ul>
<li><code>Options</code>: 用于控制数据库级别的全局配置</li>
<li><code>ReadOptions</code>: 用于控制数据库读取操作的行为</li>
<li><code>WriteOptions</code>: 用于控制数据库写入操作的行为</li>
</ul>
<h3 id="Options-1"><a href="#Options-1" class="headerlink" title="Options"></a>Options</h3><p>首先我们先给出<code>Options</code>的详细定义，实际上<code>Options</code>是一个开放式的结构体，其中内部的所有参数都是公开可修改的。</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Options to control the behavior of a database (passed to DB::Open)</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LEVELDB_EXPORT</span> Options &#123;</span><br><span class="line">  <span class="comment">// Create an Options object with default values for all fields.</span></span><br><span class="line">  <span class="built_in">Options</span>();</span><br><span class="line">  <span class="type">const</span> Comparator* comparator;</span><br><span class="line">  <span class="type">bool</span> create_if_missing            = <span class="literal">false</span>;</span><br><span class="line">  <span class="type">bool</span> error_if_exists              = <span class="literal">false</span>;</span><br><span class="line">  <span class="type">bool</span> paranoid_checks              = <span class="literal">false</span>;</span><br><span class="line">  Env* env;</span><br><span class="line">  Logger* info_log                  = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="type">size_t</span> write_buffer_size          = <span class="number">4</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">  <span class="type">int</span> max_open_files                = <span class="number">1000</span>;</span><br><span class="line">  Cache* block_cache                = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="type">size_t</span> block_size                 = <span class="number">4</span> * <span class="number">1024</span>;</span><br><span class="line">  <span class="type">int</span> block_restart_interval        = <span class="number">16</span>;</span><br><span class="line">  <span class="type">size_t</span> max_file_size              = <span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">  CompressionType compression       = kSnappyCompression;</span><br><span class="line">  <span class="type">int</span> zstd_compression_level        = <span class="number">1</span>;</span><br><span class="line">  <span class="type">bool</span> reuse_logs                   = <span class="literal">false</span>;</span><br><span class="line">  <span class="type">const</span> FilterPolicy* filter_policy = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>comparator</code><ul>
<li>作用：用于定义表中键的排序方式。</li>
<li>默认值：按字节进行字典序排序</li>
<li>限制：<strong>用户可以提供自定义的比较器，用于定义键的顺序。必须确保与以前打开数据库时使用的比较器一致，否则会出现排序不一致的问题，导致数据无法正确读取</strong>。</li>
</ul>
</li>
<li><code>create_if_missing</code><ul>
<li>作用：如果数据库文件不存在，是否自动创建对应的数据库文件</li>
<li>默认值：<code>false</code></li>
<li>限制：<strong>当打开数据库时，如果该数据库不存在，设置为 true 时，LevelDB 会自动创建一个新数据库。如果设置为 false 并且数据库不存在，则返回错误</strong>。</li>
</ul>
</li>
<li><code>error_if_exists</code><ul>
<li>作用：如果数据库文件已经存在，是否返回错误</li>
<li>默认值：<code>false</code></li>
<li>限制：<strong>当创建新数据库时，如果该数据库已经存在，设置为 true 可避免覆盖现有数据</strong>。</li>
</ul>
</li>
<li><code>paranoid_checks</code><ul>
<li>作用：是否开启严格的数据检查</li>
<li>默认值：<code>false</code></li>
<li>限制：<strong>开启后，数据库操作过程中会进行更严格的检查。如果发现数据损坏，操作会提前终止。适合在对数据完整性要求非常高的场景下使用</strong>。</li>
</ul>
</li>
<li><code>env</code><ul>
<li>作用: 用于与环境交互，例如读取&#x2F;写入文件、调度后台任务等。 </li>
<li>默认值：<code>Env::Default()</code>。 </li>
<li>限制：可自定义 env，例如用于模拟不同的操作环境或自定义文件系统行为。</li>
</ul>
</li>
<li><code>info_log</code><ul>
<li>作用：用于记录数据库内部的进度和错误信息</li>
<li>默认值：<code>nullptr</code>，表示日志信息会被写入数据库所在目录中的文件</li>
<li>限制：如果用户希望将日志信息记录到指定位置，可以提供自定义的日志对象</li>
</ul>
</li>
<li><code>write_buffer_size</code><ul>
<li>作用：在内存中构建数据的大小，达到该值后会将其转换为排序的磁盘文件</li>
<li>默认值：<code>4MB</code></li>
<li>限制：<strong>增大此值可以提升写入性能，尤其是批量写入时。不过，较大的 write_buffer_size 也会导致在数据库打开时恢复时间更长</strong></li>
</ul>
</li>
<li><code>max_open_files</code><ul>
<li>作用：数据库可以打开的最大文件数</li>
<li>默认值：1000</li>
<li>限制：设置更大的值可以减少文件频繁打开和关闭的开销，适用于工作集较大的数据库。每个 SSTable 文件需要一个文件句柄，因此较大的工作集需要较多的文件打开数</li>
</ul>
</li>
<li><code>block_cache</code><ul>
<li>作用：为块提供缓存。如果为 <code>nullptr</code>，则 LevelDB 会自动创建并使用一个 8MB 的内部缓存</li>
<li>默认值: <code>nullptr</code>(<code>8MB</code>)</li>
<li>限制：用户可以自定义块缓存对象，以优化读取性能，减少磁盘读取次数</li>
</ul>
</li>
<li><code>block_size</code><ul>
<li>作用：每个块中存放的用户数据的近似大小，块是从磁盘读取的基本单位</li>
<li>默认值: <code>4KB</code></li>
<li>限制：较大的块可以减少元数据的存储量，但可能增加读取非必要数据的开销（读放大）。较小的块适合随机读取，较大的块则适合顺序读取</li>
</ul>
</li>
<li><code>block_restart_interval</code><ul>
<li>作用：用于键的增量编码，每隔多少个键进行一次重启点的记录</li>
<li>默认值：<code>16</code></li>
<li>限制：<strong>大多数情况下无需修改此参数。该值影响键的存储和读取的效率</strong></li>
</ul>
</li>
<li><code>max_file_size</code><ul>
<li>作用：写入到一个文件中的最大字节数，达到该值后会切换到新文件</li>
<li>默认值：<code>2MB</code></li>
<li>限制：在初次加载大量数据时，增大此值可以减少文件数，但会导致更长的压缩时间，从而影响性能</li>
</ul>
</li>
<li><code>compression</code><ul>
<li>作用：指定使用的压缩算法，块可能会在存储到文件之前进行压缩</li>
<li>默认值：<code>kSnappyCompression</code></li>
<li>限制：Snappy 是轻量且快速的压缩算法，适合大多数场景。如果需要更高的压缩率，可以选择其他算法，但可能会牺牲一些性能。如果不希望压缩，可以选择 kNoCompression</li>
</ul>
</li>
<li><code>zstd_compression_level</code><ul>
<li>作用：为 <code>Zstandard</code> 压缩算法指定压缩级别</li>
<li>默认值：1</li>
<li>限制：Zstandard 支持不同的压缩级别，较高的压缩级别提供更好的压缩率，但压缩和解压缩速度会变慢。该参数适用于使用 Zstandard 压缩时的调优</li>
</ul>
</li>
<li><code>reuse_logs</code><ul>
<li>作用：是否在打开数据库时重用现有的 <code>MANIFEST</code> 和日志文件。</li>
<li>默认值：<code>false</code></li>
<li>限制：<strong>设置为 true 时，数据库在打开时会重用现有的日志文件，可能会显著加快打开速度，但这个特性是实验性的</strong>。</li>
</ul>
</li>
<li><code>filter_policy</code><ul>
<li>作用：使用指定的过滤策略来减少磁盘读取。很多应用将从 <code>NewBloomFilterPolicy()</code> 的结果中受益</li>
<li>默认值：<code>nullptr</code></li>
<li>限制：可以使用布隆过滤器来减少不必要的磁盘读取，适用于大多数场景。布隆过滤器能有效判断某个键是否存在于 SSTable 中，从而避免读取不存在的键</li>
</ul>
</li>
</ul>
<hr>
<h3 id="ReadOptions"><a href="#ReadOptions" class="headerlink" title="ReadOptions"></a>ReadOptions</h3><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Options that control read operations</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LEVELDB_EXPORT</span> ReadOptions &#123;</span><br><span class="line">  <span class="type">bool</span> verify_checksums     = <span class="literal">false</span>;</span><br><span class="line">  <span class="type">bool</span> fill_cache           = <span class="literal">true</span>;</span><br><span class="line">  <span class="type">const</span> Snapshot* snapshot  = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>verify_checksums</code><ul>
<li>作用：是否验证从底层存储读取的数据的校验和（checksum）</li>
<li>默认值：<code>false</code></li>
<li>限制：当设置为 true 时，每次读取数据时都会对其进行校验和验证，以确保数据在存储和传输过程中没有被损坏。启用此选项可以增强数据完整性保证，但会增加读取操作的开销。</li>
</ul>
</li>
<li><code>fill_cache</code><ul>
<li>作用：读取的数据是否应缓存到内存中（块缓存）</li>
<li>默认值：<code>true</code></li>
<li>限制：当设置为 true 时，读取的数据会被放入块缓存中，后续读取相同的数据可以直接从内存中获取，从而提高读取速度。如果设置为 false，读取的数据不会被缓存，适合于不常访问或一次性读取的大数据块场景，例如批量扫描操作。</li>
</ul>
</li>
<li><code>snapshot</code><ul>
<li>作用：用于指定读取操作的快照。</li>
<li>默认值：<code>nullptr</code>(隐式使用读取操作开始时的数据库状态快照)</li>
<li>限制: 快照是一种数据库在某一时刻的静态视图，允许在一致性要求较高的场景中进行读取操作。即使在读取期间数据库发生了写操作，读取的数据也依然是快照时刻的数据。如果不指定快照（snapshot &#x3D; nullptr），则默认读取操作会使用该操作开始时数据库的当前状态</li>
</ul>
</li>
</ul>
<hr>
<h3 id="WriteOptions"><a href="#WriteOptions" class="headerlink" title="WriteOptions"></a>WriteOptions</h3><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Options that control write operations</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LEVELDB_EXPORT</span> WriteOptions &#123;</span><br><span class="line">  <span class="built_in">WriteOptions</span>() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="type">bool</span> sync      = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>sync</code><ul>
<li>作用：决定写操作在操作系统的缓冲区缓存被刷新到磁盘之前，是否需要等待</li>
<li>默认值：<code>false</code></li>
<li>限制：<ul>
<li>sync &#x3D; true：表示写操作完成后，必须将数据同步刷新到磁盘。这通过调用 fsync() 或类似的系统调用来确保数据已真正写入磁盘，而不是仅仅保存在操作系统的内存缓存中。这种方式会使写操作变得较慢，但提供了更强的持久性保证。如果机器或操作系统崩溃，数据不会丢失。</li>
<li>sync &#x3D; false：表示写操作不会立即同步到磁盘，数据会暂时保存在操作系统的缓存中。这会使写操作更快，但如果机器崩溃（例如断电或操作系统崩溃），缓存中的数据可能丢失。但如果只是进程崩溃（机器没有重启），数据依然可以从操作系统缓存中恢复。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="DBImpl-DBImpl"><a href="#DBImpl-DBImpl" class="headerlink" title="DBImpl::DBImpl"></a>DBImpl::DBImpl</h2><p>这里只会局部的介绍<code>DBImpl</code>，并不会对<code>DBImpl</code>的所有实现进行分析，做到了解必要，忽略其他的干扰项。</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">DBImpl::<span class="built_in">DBImpl</span>(<span class="type">const</span> Options&amp; raw_options, <span class="type">const</span> std::string&amp; dbname)</span><br><span class="line">    : <span class="built_in">env_</span>(raw_options.env),</span><br><span class="line">      <span class="built_in">internal_comparator_</span>(raw_options.comparator),</span><br><span class="line">      <span class="built_in">internal_filter_policy_</span>(raw_options.filter_policy),</span><br><span class="line">      <span class="built_in">options_</span>(<span class="built_in">SanitizeOptions</span>(</span><br><span class="line">        dbname, &amp;internal_comparator_, &amp;internal_filter_policy_, raw_options)),</span><br><span class="line">      <span class="built_in">owns_info_log_</span>(options_.info_log != raw_options.info_log),</span><br><span class="line">      <span class="built_in">owns_cache_</span>(options_.block_cache != raw_options.block_cache),</span><br><span class="line">      <span class="built_in">dbname_</span>(dbname),</span><br><span class="line">      <span class="built_in">table_cache_</span>(<span class="keyword">new</span> <span class="built_in">TableCache</span>(dbname_, options_, <span class="built_in">TableCacheSize</span>(options_))),</span><br><span class="line">      <span class="built_in">db_lock_</span>(<span class="literal">nullptr</span>),</span><br><span class="line">      <span class="built_in">shutting_down_</span>(<span class="literal">false</span>),</span><br><span class="line">      <span class="built_in">background_work_finished_signal_</span>(&amp;mutex_),</span><br><span class="line">      <span class="built_in">mem_</span>(<span class="literal">nullptr</span>),</span><br><span class="line">      <span class="built_in">imm_</span>(<span class="literal">nullptr</span>),</span><br><span class="line">      <span class="built_in">has_imm_</span>(<span class="literal">false</span>),</span><br><span class="line">      <span class="built_in">logfile_</span>(<span class="literal">nullptr</span>),</span><br><span class="line">      <span class="built_in">logfile_number_</span>(<span class="number">0</span>),</span><br><span class="line">      <span class="built_in">log_</span>(<span class="literal">nullptr</span>),</span><br><span class="line">      <span class="built_in">seed_</span>(<span class="number">0</span>),</span><br><span class="line">      <span class="built_in">tmp_batch_</span>(<span class="keyword">new</span> WriteBatch),</span><br><span class="line">      <span class="built_in">background_compaction_scheduled_</span>(<span class="literal">false</span>),</span><br><span class="line">      <span class="built_in">manual_compaction_</span>(<span class="literal">nullptr</span>),</span><br><span class="line">      <span class="built_in">versions_</span>(</span><br><span class="line">        <span class="keyword">new</span> <span class="built_in">VersionSet</span>(dbname_, &amp;options_, table_cache_, &amp;internal_comparator_)) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>在构造上述中，对于从<code>Options</code>中取出并直接赋值的字段不做其他解释，这里重点介绍其他字段的含义和作用。</p>
<p><code>SanitizeOptions</code>函数用于对用户提供的<code>raw_options</code>进行合理性验证和修改，确保数据库操作不会因为不合理的参数导致问题。<code>SanitizeOptions</code>函数根据默认值和限制，对选项中的字段进行调整。</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Options <span class="title">SanitizeOptions</span><span class="params">(<span class="type">const</span> std::string&amp; dbname,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="type">const</span> InternalKeyComparator* icmp,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="type">const</span> InternalFilterPolicy* ipolicy,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="type">const</span> Options&amp; src)</span> </span>&#123;</span><br><span class="line">  Options result = src;</span><br><span class="line">  result.comparator = icmp;</span><br><span class="line">  result.filter_policy = (src.filter_policy != <span class="literal">nullptr</span>) ? ipolicy : <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先<code>SanitizeOptions</code>会创建一个<code>src options</code>的副本<code>result</code>用于验证和修改为合理的选项，并在最后返回。然后将将内部的比较器 <code>icmp</code> 赋值给 <code>result.comparator</code>，确保使用内部的比较器，而不是用户自定义的 comparator。</p>
<p>如果用户在 src 中提供了 filter_policy，则将内部的 ipolicy 赋值给 result.filter_policy。否则，设为 nullptr。这保证了如果用户没有指定过滤策略，系统不会使用过滤器。</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">V</span>&gt;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">ClipToRange</span><span class="params">(T* ptr, V minvalue, V maxvalue)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">static_cast</span>&lt;V&gt;(*ptr) &gt; maxvalue) *ptr = maxvalue;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">static_cast</span>&lt;V&gt;(*ptr) &lt; minvalue) *ptr = minvalue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">ClipToRange</span>(&amp;result.max_open_files, <span class="number">64</span> + kNumNonTableCacheFiles, <span class="number">50000</span>);</span><br><span class="line"><span class="built_in">ClipToRange</span>(&amp;result.write_buffer_size, <span class="number">64</span> &lt;&lt; <span class="number">10</span>, <span class="number">1</span> &lt;&lt; <span class="number">30</span>);</span><br><span class="line"><span class="built_in">ClipToRange</span>(&amp;result.max_file_size, <span class="number">1</span> &lt;&lt; <span class="number">20</span>, <span class="number">1</span> &lt;&lt; <span class="number">30</span>);</span><br><span class="line"><span class="built_in">ClipToRange</span>(&amp;result.block_size, <span class="number">1</span> &lt;&lt; <span class="number">10</span>, <span class="number">4</span> &lt;&lt; <span class="number">20</span>);</span><br></pre></td></tr></table></figure>

<p>函数<code>ClipToRange</code>确保某个指针指向的值 ptr 被限制在 $[minvalue, maxvalue]$ 范围内。如果 ptr 的值超出这个范围，函数将其裁剪到范围的边界值。因此，这里会对<code>max_open_files</code>、<code>write_buffer_size</code>、<code>max_file_size</code>和<code>block_size</code>选项的值进行判断是否位于合理的范围内，如果不在则进行裁剪为合适的值。</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (result.info_log == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// Open a log file in the same directory as the db</span></span><br><span class="line">    src.env-&gt;<span class="built_in">CreateDir</span>(dbname);  <span class="comment">// In case it does not exist</span></span><br><span class="line">    src.env-&gt;<span class="built_in">RenameFile</span>(<span class="built_in">InfoLogFileName</span>(dbname), <span class="built_in">OldInfoLogFileName</span>(dbname));</span><br><span class="line">    Status s = src.env-&gt;<span class="built_in">NewLogger</span>(<span class="built_in">InfoLogFileName</span>(dbname), &amp;result.info_log);</span><br><span class="line">    <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      <span class="comment">// No place suitable for logging</span></span><br><span class="line">      result.info_log = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果 info_log 为 nullptr（用户没有指定日志记录器），则在数据库路径中创建日志文件目录。如果目录不存在，则创建该目录。同时将将当前的日志文件重命名为 “旧的日志文件”。InfoLogFileName(dbname) 获取日志文件名，OldInfoLogFileName(dbname) 获取旧日志文件名。这样做可以避免覆盖现有日志。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 实际逻辑为：</span></span><br><span class="line"><span class="comment"># 如果目前有一个日志文件为`dbname/LOG`，那么首先先重命名该文件</span></span><br><span class="line"><span class="built_in">mv</span> dbname/LOG dbname/LOG.old</span><br><span class="line"><span class="comment"># 然后再将logger指向新的`dbname/LOG`，这样就不会覆盖原有的`dbname/LOG`</span></span><br></pre></td></tr></table></figure>

<p>创建新的日志记录器 Logger，并将其指向新的日志文件。NewLogger 函数负责创建并打开日志文件用于写入。如果创建日志文件失败（即 s.ok() 返回 false），将 info_log 置为 nullptr，表示无法创建日志记录器。</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (result.block_cache == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    result.block_cache = <span class="built_in">NewLRUCache</span>(<span class="number">8</span> &lt;&lt; <span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>

<p>如果用户没有提供缓存，则创建一个新的 <code>LRUCache</code> 对象，大小为 $8MB(8 &lt;&lt; 20)$。<code>LRUCache</code>用于缓存数据库的块，以减少磁盘读取，提高性能。</p>
<p>最终返回验证完合理性的选项<code>result</code>。以下是对<code>DBImpl:DBImpl</code>初始化的成员含义做出解释：</p>
<ul>
<li><code>owns_info_log_</code><ul>
<li>owns_info_log_ 用于标记当前对象是否拥有 info_log_ 日志文件对象。如果 options_.info_log 与用户提供的 raw_options.info_log 不同，则表示数据库自己拥有并负责管理日志文件</li>
</ul>
</li>
<li><code>owns_cache_</code><ul>
<li>owns_cache_ 用于标记数据库是否拥有 block_cache 块缓存。如果 options_.block_cache 和用户传入的 raw_options.block_cache 不同，则表示数据库拥有自己的块缓存并负责其管理</li>
</ul>
</li>
<li><code>table_cache_</code><ul>
<li>table_cache_ 是用于缓存数据库表（即 SSTable）的缓存系统。它基于数据库路径 dbname_ 和选项 options_ 创建，内部管理 SSTable 文件的元数据信息</li>
</ul>
</li>
<li><code>db_lock_</code><ul>
<li>db_lock_ 用于文件锁定，防止多个数据库实例同时打开同一个数据库路径。初始化时为 nullptr，稍后会在打开数据库时进行文件锁定操作</li>
</ul>
</li>
<li><code>shutting_down_</code><ul>
<li>shutting_down_ 是一个标志，用于指示数据库是否正在关闭操作。当 true 时，表示后台任务和写操作需要终止。</li>
</ul>
</li>
<li><code>background_work_finished_signal_</code><ul>
<li>background_work_finished_signal_ 是一个条件变量，用于在后台线程完成工作（如压缩）后，通知主线程或其他等待的线程。它与 mutex_ 关联，保证多线程同步。</li>
</ul>
</li>
<li><code>mem_</code><ul>
<li>mem_ 是当前内存中的 MemTable，用于存储最近的写入操作，尚未持久化到磁盘。在数据库启动时为 nullptr，后续会分配</li>
</ul>
</li>
<li><code>imm_</code><ul>
<li>imm_ 是不可变的 MemTable，即当一个 MemTable 达到大小限制后，它被标记为不可变，等待写入到磁盘。初始化时为 nullptr</li>
</ul>
</li>
<li><code>has_imm_</code><ul>
<li>has_imm_ 用于标记是否存在不可变的 MemTable。当为 true 时，表示 imm_ 需要被持久化到磁盘</li>
</ul>
</li>
<li><code>logfile_</code><ul>
<li>logfile_ 是当前日志文件，用于记录写入操作（Write-Ahead Logging）。每个 MemTable 都有一个相对应的日志文件，初始化时为 nullptr</li>
</ul>
</li>
<li><code>logfile_number_</code><ul>
<li>logfile_number_ 是日志文件的编号，用于标识当前的日志文件。初始化时为 0。</li>
</ul>
</li>
<li><code>log_</code><ul>
<li>log_ 是日志写入器，用于将写操作序列化并写入日志文件。初始化时为 nullptr，稍后会创建。</li>
</ul>
</li>
<li><code>seed_</code><ul>
<li>seed_ 是随机数生成的种子，主要用于某些随机化操作，例如压缩的延时处理。</li>
</ul>
</li>
<li><code>tmp_batch_</code><ul>
<li>tmp_batch_ 是一个临时的批量写入对象，帮助合并多个写入操作，以提高效率。</li>
</ul>
</li>
<li><code>background_compaction_scheduled_</code><ul>
<li>background_compaction_scheduled_ 是一个标志，指示是否已经安排了后台压缩任务。若为 true，表示压缩任务正在进行或已经计划好</li>
</ul>
</li>
<li><code>manual_compaction_</code><ul>
<li>manual_compaction_ 用于手动触发的压缩任务。初始化时为 nullptr，表示当前没有手动压缩任务</li>
</ul>
</li>
<li><code>versions_</code><ul>
<li>versions_ 管理数据库的版本信息和元数据。VersionSet 负责维护 SSTable 文件的列表以及压缩操作的策略。</li>
</ul>
</li>
</ul>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>Chen Miao</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="https://chenmiaoi.github.io/2024/09/16/LevelDB-A-whole-Open-Operation/">https://chenmiaoi.github.io/2024/09/16/LevelDB-A-whole-Open-Operation/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2024 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>Do you believe in <strong>DESTINY</strong>?</span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/leveldb/"># leveldb</a>
                    
                        <a href="/tags/option/"># option</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2024/09/26/Raft-An-Understandable-Consensus-Algorithm/">Raft: An Understandable Consensus Algorithm</a>
            
            
            <a class="next" rel="next" href="/2024/09/16/LevelDB-A-whole-Put-Operation/">LevelDB: A Whole Put Operation</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Chen Miao | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>