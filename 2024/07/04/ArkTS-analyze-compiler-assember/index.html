<!DOCTYPE html>
<html lang="en,zh,default">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Chen Miao">





<title>ArkTS: Analyze Compiler_assembler | Nay&#39;s Blog</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
            <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    "HTML-CSS": {
        preferredFont: "TeX",
        availableFonts: ["STIX","TeX"],
        linebreaks: { automatic:true },
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ],
        processEscapes: true,
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
        Macros: { href: "{}" }
    },
    messageStyle: "none"
    });
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script>


        
    


<meta name="generator" content="Hexo 7.3.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Nayy&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Nayy&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">ArkTS: Analyze Compiler_assembler</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">Chen Miao</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">July 4, 2024&nbsp;&nbsp;9:39:39</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/arkts/">arkts</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="ArkTS-Assembler"><a href="#ArkTS-Assembler" class="headerlink" title="ArkTS Assembler"></a>ArkTS Assembler</h1><p>在此次的任务中，我们主要是对于<code>riscv64</code>架构下的汇编进行处理，按照之前的经验来看，<strong>目前已有的</strong><code>riscv64</code><strong>汇编代码处理逻辑是依托于</strong><code>aarch64</code><strong>而来</strong>。因此，在本节中会详细解析两个部分：<code>assembler.h</code>和<code>assembler_aarch64</code>。</p>
<h2 id="Assembler"><a href="#Assembler" class="headerlink" title="Assembler"></a>Assembler</h2><p>在这个小节中，我们会聚焦于<code>assembler.h</code>中的关键代码，并且给出后续<code>riscv64</code>可能的方向。</p>
<p>首先，在<code>assembler.h</code>中首先有一个名为<code>GCStackMapRegisters</code>的类，在<code>ArkTS</code>中，存在<code>GC</code>机制。因此，这里的<code>GCStackMapRegisters</code><strong>可能是用于垃圾回收机制中的栈映射寄存器。在垃圾回收算法中，栈映射寄存器用于记录程序执行过程中的栈帧信息，以便正确地识别和回收不再使用的对象。栈映射寄存器通常用于确定每个栈帧的边界和对象引用的位置。通过分析栈映射寄存器中的值，垃圾回收器可以构建出程序的栈帧结构，识别出栈中的对象引用，并进行相应的垃圾回收操作</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GCStackMapRegisters</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(PANDA_TARGET_AMD64)</span></span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> SP = <span class="number">7</span>;  <span class="comment">/* x7 */</span></span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> FP = <span class="number">6</span>;  <span class="comment">/* x6 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(PANDA_TARGET_ARM64)</span></span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> SP = <span class="number">31</span>;  <span class="comment">/* x31 */</span></span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> FP = <span class="number">29</span>;  <span class="comment">/* x29 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(PANDA_TARGET_ARM32)</span></span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> SP = <span class="number">13</span>;  <span class="comment">/* x13 */</span></span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> FP = <span class="number">11</span>;  <span class="comment">/* x11 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(PANDA_TARGET_RISCV64)</span></span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> SP = <span class="number">2</span>;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> FP = <span class="number">8</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> SP = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> FP = <span class="number">-1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>而在该内中的存在两个尚未完全的函数<code>GetFpRegByTriple</code>和<code>GetSpRegByTriple</code>，因为这两个函数中均未对<code>RISCV64</code>进行实现，因此可能在后续实现中，需要对其进行补全。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">GetFpRegByTriple</span><span class="params">(Triple triple)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> fp = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">switch</span> (triple) &#123;</span><br><span class="line">        <span class="keyword">case</span> Triple::TRIPLE_AMD64:</span><br><span class="line">            fp = <span class="number">6</span>;  <span class="comment">/* x6 */</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Triple::TRIPLE_ARM32:</span><br><span class="line">            fp = <span class="number">11</span>;  <span class="comment">/* x11 */</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Triple::TRIPLE_AARCH64:</span><br><span class="line">            fp = <span class="number">29</span>;  <span class="comment">/* x29 */</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">UNREACHABLE</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而<code>GetFpRegByTriple</code>和<code>GetSpRegByTriple</code>唯一一次被调用则是位于<code>ecmascript/stackmap/llvm_stackmap_type.cpp</code>中。至于具体作用，如果后续需要则会继续分析。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> fpReg = GCStackMapRegisters::<span class="built_in">GetFpRegByTriple</span>(triple);</span><br><span class="line"><span class="keyword">auto</span> spReg = GCStackMapRegisters::<span class="built_in">GetSpRegByTriple</span>(triple);</span><br></pre></td></tr></table></figure>

<p>继续往下看，则会看见一段异常重要的代码<code>FrameCompletionPos</code>，(<strong>根据自己的猜测</strong>)<strong>用于表示从<code>C++</code>代码到汇编代码的转换和从汇编代码返回到<code>C++</code>代码时的指令数量</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">FrameCompletionPos</span> : <span class="type">uint64_t</span> &#123;</span><br><span class="line">    <span class="comment">// X64</span></span><br><span class="line">    X64CppToAsmInterp = <span class="number">28</span>,</span><br><span class="line">    X64AsmInterpToCpp = <span class="number">9</span>,</span><br><span class="line">    X64EntryFrameDuration = <span class="number">70</span>,</span><br><span class="line">    <span class="comment">// ARM64</span></span><br><span class="line">    ARM64CppToAsmInterp = <span class="number">56</span>,</span><br><span class="line">    ARM64AsmInterpToCpp = <span class="number">40</span>,</span><br><span class="line">    ARM64EntryFrameDuration = <span class="number">116</span>,</span><br><span class="line">    <span class="comment">// RISCV64</span></span><br><span class="line">    RISCV64EntryFrameDuration = <span class="number">140</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>对于<code>X64(x86-64)</code>体系结构： <ul>
<li><code>X64CppToAsmInterp</code> 表示从<code>C++</code>代码转换到汇编代码时的指令数量为 28。 </li>
<li><code>X64AsmInterpToCpp</code> 表示从汇编代码返回到<code>C++</code>代码时的指令数量为 9。 </li>
<li><code>X64EntryFrameDuration</code> 表示使用汇编解释器(<code>AsmInterpreterEntryFrame</code>)时的汇编帧的指令数量为 70。</li>
</ul>
</li>
<li>对于<code>ARM64(ARM64)</code>体系结构： <ul>
<li><code>ARM64CppToAsmInterp</code> 表示从<code>C++</code>代码转换到汇编代码时的指令数量为 56。 </li>
<li><code>ARM64AsmInterpToCpp</code> 表示从汇编代码返回到<code>C++</code>代码时的指令数量为 40。 </li>
<li><code>ARM64EntryFrameDuration</code> 表示使用汇编解释器时的汇编帧的指令数量为 116。</li>
</ul>
</li>
<li>对于<code>RISCV64(RISC-V64)</code>体系结构： <ul>
<li><code>RISCV64EntryFrameDuration</code> 表示使用汇编解释器时的汇编帧的指令数量为 140。</li>
</ul>
</li>
</ul>
<p>这里的代码实际上在我们处理<code>RISC-V64 Assembler</code>时没有影响，而是会在另外一个极其重要、并且需要我们处理的模块<code>stub trapoline</code>中进行使用，这里不做过多介绍：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((end - begin) != FrameCompletionPos::RISCV64EntryFrameDuration)</span><br></pre></td></tr></table></figure>

<h3 id="Label"><a href="#Label" class="headerlink" title="Label"></a>Label</h3><p>在这个部分中，主要介绍<strong>用于处理汇编逻辑中的跳转指令的标签</strong>。在<code>ArkTS</code>的运行时中使用一个名为<code>Label</code>的类进行标识：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Label</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsBound</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsLinked</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsLinkedNear</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">uint32_t</span> <span class="title">GetPos</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">uint32_t</span> <span class="title">GetLinkedPos</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">BindTo</span><span class="params">(<span class="type">int32_t</span> pos)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">LinkTo</span><span class="params">(<span class="type">int32_t</span> pos)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">UnlinkNearPos</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">LinkNearPos</span><span class="params">(<span class="type">uint32_t</span> pos)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">uint32_t</span> <span class="title">GetLinkedNearPos</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int32_t</span> pos_ = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint32_t</span> nearPos_ = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>首先我们需要区分两个概念：<code>绑定(bound)</code>和<code>链接(link)</code>。在<code>ArkTS</code>中，绑定和链接是两个相似，但行为不同的操作：</p>
<ul>
<li><code>bound</code>指的是<strong>将标签绑定到特定的位置。绑定标签意味着将标签与某个位置相关联，<em>通常用于表示位于后面的标签</em></strong>。</li>
<li><code>link</code>指的是<strong>将标签链接到特定的位置。链接标签意味着将标签与某个位置相关联，<em>通常用于表示位于前面的标签</em></strong>。</li>
</ul>
<p>这里我们可以使用实际的汇编代码进行解释：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">; 绑定标签示例</span><br><span class="line">section .text</span><br><span class="line">    global _start</span><br><span class="line"></span><br><span class="line">_start:             ; 链接的位置</span><br><span class="line">    ; 绑定标签到位置</span><br><span class="line">    jmp bind_label</span><br><span class="line"></span><br><span class="line">bind_label:</span><br><span class="line">    ; 这里是绑定的位置</span><br><span class="line">    ; ...</span><br><span class="line">    jmp _start       ; 链接回起始位置</span><br><span class="line"></span><br><span class="line">    ; 继续执行其他代码...</span><br></pre></td></tr></table></figure>

<p>现在来解释各个函数的作用：</p>
<ul>
<li><code>IsBound()</code> 函数用于检查标签是否已绑定。如果 $pos_ \gt 0$，则表示标签已绑定。</li>
<li><code>IsLinked()</code> 函数用于检查标签是否已链接。如果 $pos_ \lt 0$，则表示标签已链接。 </li>
<li><code>IsLinkedNear()</code> 函数用于检查标签是否已链接至近跳转位置。如果 $nearPos_ \gt 0$，则表示标签已链接至近跳转位置。 </li>
<li><code>GetPos()</code> 函数用于获取标签的位置。返回 $pos_ - 1$ 的无符号整数值。 </li>
<li><code>GetLinkedPos()</code> 函数用于获取链接的位置。如果标签未绑定，则返回 $-pos_ - 1$ 的无符号整数值。 </li>
<li><code>BindTo()</code> 函数将标签绑定到给定的位置。将 <code>pos_</code> 设置为 $pos + 1$，以跳过偏移为 0 的位置。 </li>
<li><code>LinkTo()</code> 函数将标签链接到给定的位置。将 <code>pos_</code> 设置为 $-(pos + 1)$，以跳过偏移为 0 的位置。 </li>
<li><code>UnlinkNearPos()</code> 函数取消链接至近跳转位置。 </li>
<li><code>LinkNearPos()</code> 函数将标签链接至近跳转位置。将 <code>nearPos_</code> 设置为 $pos + 1$，以跳过偏移为 0 的位置。 </li>
<li><code>GetLinkedNearPos()</code> 函数用于获取链接至近跳转位置的位置。如果标签未绑定，则返回 $nearPos_ - 1$ 的无符号整数值。</li>
</ul>
<h3 id="Assembler-1"><a href="#Assembler-1" class="headerlink" title="Assembler"></a>Assembler</h3><p>接下来则是整个<code>assembler.h</code>中最为重要的模块，所有架构的汇编处理逻辑都需要继承于<code>Assembler</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Assembler</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Assembler</span><span class="params">(Chunk *chunk)</span></span></span><br><span class="line"><span class="function">        : buffer_(chunk) &#123;</span>&#125;</span><br><span class="line">    ~<span class="built_in">Assembler</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">EmitU8</span><span class="params">(<span class="type">uint8_t</span> v)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">EmitI8</span><span class="params">(<span class="type">int8_t</span> v)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">EmitU16</span><span class="params">(<span class="type">uint16_t</span> v)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">EmitU32</span><span class="params">(<span class="type">uint32_t</span> v)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">EmitI32</span><span class="params">(<span class="type">int32_t</span> v)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">EmitU64</span><span class="params">(<span class="type">uint64_t</span> v)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PutI8</span><span class="params">(<span class="type">size_t</span> offset, <span class="type">int8_t</span> data)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PutI32</span><span class="params">(<span class="type">size_t</span> offset, <span class="type">int32_t</span> data)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">uint32_t</span> <span class="title">GetU32</span><span class="params">(<span class="type">size_t</span> offset)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int8_t</span> <span class="title">GetI8</span><span class="params">(<span class="type">size_t</span> offset)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">uint8_t</span> <span class="title">GetU8</span><span class="params">(<span class="type">size_t</span> offset)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">GetCurrentPosition</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">uint8_t</span> *<span class="title">GetBegin</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">InRangeN</span><span class="params">(<span class="type">int32_t</span> x, <span class="type">uint32_t</span> n)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">InRange8</span><span class="params">(<span class="type">int32_t</span> x)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">GetFrameCompletionPos</span><span class="params">(<span class="type">uint64_t</span> &amp;headerSize, <span class="type">uint64_t</span> &amp;tailSize, <span class="type">uint64_t</span> &amp;entryDuration)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    DynChunk buffer_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在<code>Assembler</code>中，<code>buffer_</code><strong>用于存储汇编的机器码</strong>，而<code>Emit*</code>则是会调用<code>buffer_.Emit*</code>进行处理逻辑，这样能够根据汇编的机器码依次正确地存入内存中，以便后续处理。</p>
<p>比如：在<code>X64</code>架构中的<code>Assembler::Addq</code>，其要处理的汇编为：<code>REX.W + 03 /r</code>。这里需要注意的是，你应该知晓<code>x64</code>架构下汇编的格式为：</p>
<p><img src="https://hexo-pirctures.oss-cn-chengdu.aliyuncs.com/imgs202407021625400.png" alt="intel x64 asm"></p>
<p>因此，首先我们需要处理<code>Instruction Prefixes</code>，然后处理<code>Opcode</code>，最后处理<code>ModR/M</code>。因为这里不需要处理<code>SIB</code>。我们重新看回<code>REX.W + 03 /r</code>，其中<code>REX.W</code>是<code>Instruction Prefixes</code>，<code>03</code>是<code>Opcode</code>，而<code>/r</code>则是<code>ModR/M</code>。而每一个段在此处都是一个字节，因此：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AssemblerX64::Addq</span><span class="params">(Register src, Register dst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">EmitRexPrefix</span>(dst, src);</span><br><span class="line">    <span class="comment">// 03 : add r64, r/m64</span></span><br><span class="line">    <span class="built_in">EmitU8</span>(<span class="number">0x03</span>);</span><br><span class="line">    <span class="built_in">EmitModrm</span>(dst, src);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EmitRexPrefix</span><span class="params">(Register reg, Register rm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 0: Extension to the MODRM.rm field B</span></span><br><span class="line">    <span class="comment">// 2: Extension to the MODRM.reg field R</span></span><br><span class="line">    <span class="built_in">EmitU8</span>(REX_PREFIX_W | (<span class="built_in">HighBit</span>(reg) &lt;&lt; <span class="number">2</span>) | <span class="built_in">HighBit</span>(rm));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EmitModrm</span><span class="params">(<span class="type">int32_t</span> reg, Register rm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">EmitU8</span>(MODE_RM | (<span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(reg) &lt;&lt; LOW_BITS_SIZE) | <span class="built_in">LowBits</span>(rm));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，我们能够看见，<code>Assembler</code>中的任何处理逻辑，都是依托于其真实汇编的机器码逻辑，并且根据其真实字节位宽进行处理，就比如<code>EmitU8</code>则是填入<code>uint8_t</code>。</p>
<p>至于<code>Put*</code>，此处不做过多介绍，其实际内部逻辑也是进行填入操作，但是会直接通过偏移量进行填入，需要我们自行保证其边界问题和内存安全问题。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">PutU32</span><span class="params">(<span class="type">size_t</span> offset, <span class="type">uint32_t</span> data)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// NOLINTNEXTLINE(cppcoreguidelines-pro-bounds-pointer-arithmetic)</span></span><br><span class="line">    *<span class="built_in">reinterpret_cast</span>&lt;<span class="type">uint32_t</span> *&gt;(buf_ + offset) = data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Aarch64-Assembler-Detail"><a href="#Aarch64-Assembler-Detail" class="headerlink" title="Aarch64 Assembler Detail"></a>Aarch64 Assembler Detail</h2><p>这一个小节主要是介绍<code>aarch64</code>架构下的汇编处理逻辑，因为<code>RISC-V64</code>架构大部分逻辑是临摹<code>aarch64</code>架构所写，因此分析<code>aarch64</code>的完整逻辑对后续开发有很大帮助。</p>
<h3 id="Register"><a href="#Register" class="headerlink" title="Register"></a>Register</h3><p>处理一个汇编首先需要解决的问题是，<strong>如何处理对应架构汇编下的对应寄存器</strong>。在<code>aarch64</code>中有两组寄存器：通用寄存器和<code>SIMD</code>寄存器。</p>
<h4 id="General-Purpose-Register"><a href="#General-Purpose-Register" class="headerlink" title="General Purpose Register"></a>General Purpose Register</h4><p>通用寄存器中的$31$个通用寄存器被命名为$R_0-R_{30}$，并在指令寄存器字段中以值$0-30$进行编码。在通用寄存器字段中，<strong>值$31$表示当前的堆栈指针或零寄存器</strong>，具体取决于指令和操作数位置。</p>
<p><img src="https://hexo-pirctures.oss-cn-chengdu.aliyuncs.com/imgs202407031538142.png" alt="Naming of general-purpose registers"></p>
<p>对于上图所给出的寄存器，这里有几个点需要注意的：</p>
<ul>
<li>$X_n$和$W_n$实际上指向的是同一组寄存器$R_n$，其只有位宽的差距；当然$WSP$和$SP$也是类似的情况。</li>
<li>没有名为$W_{31}$或$X_{31}$的寄存器，使用$WZR$或$XZR$来表示第$31$号的零寄存器，当读写该寄存器时，其表现为返回零值或抛弃写入值。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">RegisterId</span> : <span class="type">uint8_t</span> &#123;</span><br><span class="line">    X0, X1, X2, X3, X4, X5, X6, X7,</span><br><span class="line">    X8, X9, X10, X11, X12, X13, X14, X15,</span><br><span class="line">    X16, X17, X18, X19, X20, X21, X22, X23,</span><br><span class="line">    X24, X25, X26, X27, X28, X29, X30, SP,</span><br><span class="line">    Zero = SP,</span><br><span class="line">    FP = X29,</span><br><span class="line">    INVALID_REG = <span class="number">0xFF</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">RegisterType</span> &#123;</span><br><span class="line">    W = <span class="number">0</span>,    <span class="comment">// 32-bits</span></span><br><span class="line">    X = <span class="number">1</span>,    <span class="comment">// 64-bits</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> RegXSize = <span class="number">64</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> RegWSize = <span class="number">32</span>;</span><br></pre></td></tr></table></figure>

<p>值得注意的是，在<code>arm</code>中$SP &#x3D; 31，ZERO &#x3D; 31，FP &#x3D; 29$。</p>
<h5 id="General-Condition"><a href="#General-Condition" class="headerlink" title="General Condition"></a>General Condition</h5><p><img src="https://hexo-pirctures.oss-cn-chengdu.aliyuncs.com/imgs202407031629956.png" alt="General Condition"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Condition</span> &#123;</span><br><span class="line">    EQ = <span class="number">0</span>,</span><br><span class="line">    NE = <span class="number">1</span>,</span><br><span class="line">    HS = <span class="number">2</span>,</span><br><span class="line">    CS = HS,</span><br><span class="line">    LO = <span class="number">3</span>,</span><br><span class="line">    CC = LO,</span><br><span class="line">    MI = <span class="number">4</span>,</span><br><span class="line">    PL = <span class="number">5</span>,</span><br><span class="line">    VS = <span class="number">6</span>,</span><br><span class="line">    VC = <span class="number">7</span>,</span><br><span class="line">    HI = <span class="number">8</span>,</span><br><span class="line">    LS = <span class="number">9</span>,</span><br><span class="line">    GE = <span class="number">10</span>,</span><br><span class="line">    LT = <span class="number">11</span>,</span><br><span class="line">    GT = <span class="number">12</span>,</span><br><span class="line">    LE = <span class="number">13</span>,</span><br><span class="line">    AL = <span class="number">14</span>,</span><br><span class="line">    NV = <span class="number">15</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="Register-Code"><a href="#Register-Code" class="headerlink" title="Register Code"></a>Register Code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Register</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Register</span>(RegisterId reg, RegisterType type = RegisterType::X) : <span class="built_in">reg_</span>(reg), <span class="built_in">type_</span>(type) &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">Register <span class="title">W</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">Register <span class="title">X</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">RegisterType <span class="title">GetType</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> RegisterId <span class="title">GetId</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">IsSp</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">IsW</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">IsValid</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span> !=(<span class="type">const</span> Register &amp;other);</span><br><span class="line">    <span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span> ==(<span class="type">const</span> Register &amp;other);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    RegisterId reg_;</span><br><span class="line">    RegisterType type_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里不需要过多的解释，根据上面的所有信息就能够自然的构建出这样的一个<code>Register</code>类型。</p>
<h4 id="SIMD-Register"><a href="#SIMD-Register" class="headerlink" title="SIMD Register"></a>SIMD Register</h4><p>在<code>aarch</code>下的<code>SIMD</code>寄存器总共有$32$个，$V_0 - V_{31}$，<strong>其用于保存标量(scalar)浮点指令的浮点操作数以及<code>SIMD</code>指令的标量(scalar)和矢量(vector)操作数</strong>。</p>
<p><strong>当它们以特定的指令形式使用时，必须进一步限定名称以指示数据形状，即数据元素大小和寄存器内元素或通道的数量</strong>。数据类型由对数据进行操作的指令助记符描述。数据类型不是由寄存器名描述的。数据类型是对每个寄存器或向量元素中的位的解释，无论这些是整数、浮点值、多项式还是加密哈希。</p>
<p><img src="https://hexo-pirctures.oss-cn-chengdu.aliyuncs.com/imgs202407031601724.png" alt="SIMD and floating-point"></p>
<p>上图中的左图表示了<code>SIMD</code>的标量寄存器名，<strong>其指定了操作标量数据时只访问高级<code>SIMD</code>和浮点寄存器的低位。未使用的高位在读取时会被忽略，在写入时会被清零</strong>。</p>
<p>而右图表示向量寄存器名，在一开始我们就说过：<strong>必须进一步限定名称以指示数据形状</strong>，也就是说，这里就给出了向量寄存器的数据形状，即数据元素大小和内部通道的数量。其中$V_n$在$V_0 - V_31$中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">VectorRegisterId</span> : <span class="type">uint8_t</span> &#123;</span><br><span class="line">    v0, v1, v2, v3, v4, v5, v6, v7,</span><br><span class="line">    v8, v9, v10, v11, v12, v13, v14, v15,</span><br><span class="line">    v16, v17, v18, v19, v20, v21, v22, v23,</span><br><span class="line">    v24, v25, v26, v27, v28, v29, v30, v31,</span><br><span class="line">    INVALID_VREG = <span class="number">0xFF</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Scale</span> &#123;</span><br><span class="line">    B = <span class="number">0</span>,</span><br><span class="line">    H = <span class="number">1</span>,</span><br><span class="line">    S = <span class="number">2</span>,</span><br><span class="line">    D = <span class="number">3</span>,</span><br><span class="line">    Q = <span class="number">4</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="SIMD-Code"><a href="#SIMD-Code" class="headerlink" title="SIMD Code"></a>SIMD Code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VectorRegister</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">VectorRegister</span><span class="params">(VectorRegisterId reg, Scale scale = D)</span> : reg_(reg), scale_(scale) &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> VectorRegisterId <span class="title">GetId</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">IsValid</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> Scale <span class="title">GetScale</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">GetRegSize</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    VectorRegisterId reg_;</span><br><span class="line">    Scale scale_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Operand"><a href="#Operand" class="headerlink" title="Operand"></a>Operand</h3><p>在<code>aarch</code>中，<code>Operand</code>的类型可以大致分为两类：<code>Data Processing</code>和<code>Load and Store</code>。为了处理这两种类型，我们在实际代码编写中需要构建两个类：<code>Operand</code>和<code>MemoryOperand</code>。其中，这两个类会由<code>Register</code>、<code>Immediate</code>、<code>Extend</code>、<code>Shift</code>和<code>AddrMode</code>分别构成。</p>
<p>对于<code>Register</code>类型这里就不再赘述，其主要<strong>管理了寄存器的编号和类型</strong>，如果是向量寄存器，则会额外管理<code>标量(scalar)</code>。</p>
<p>对于<code>Immediate</code>类型而言，只是一个最为简单的数据封装，分为<code>Immediate</code>和<code>LogicImmediate</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Immediate</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Immediate</span>(<span class="type">int64_t</span> value) : <span class="built_in">value_</span>(value) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Immediate</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int64_t</span> <span class="title">Value</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int64_t</span> value_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LogicalImmediate</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> LogicalImmediate <span class="title">Create</span><span class="params">(<span class="type">uint64_t</span> imm, <span class="type">int</span> width)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Value</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsValid</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Is64bit</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">LogicalImmediate</span><span class="params">(<span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function">        : imm_(value) &#123;</span>&#125;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> InvalidLogicalImmediate = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> imm_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>而<code>Extend</code>则是作为<code>Immediate</code>的扩展类型指导，<strong>用于标记是否需要进行立即数扩展和以哪一种方式进行扩展</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Extend</span> : <span class="type">uint8_t</span> &#123;</span><br><span class="line">    NO_EXTEND = <span class="number">0xFF</span>,</span><br><span class="line">    UXTB = <span class="number">0</span>,   <span class="comment">/* zero extend to byte */</span></span><br><span class="line">    UXTH = <span class="number">1</span>,   <span class="comment">/* zero extend to half word */</span></span><br><span class="line">    UXTW = <span class="number">2</span>,   <span class="comment">/* zero extend to word */</span></span><br><span class="line">    UXTX = <span class="number">3</span>,   <span class="comment">/* zero extend to 64bit */</span></span><br><span class="line">    SXTB = <span class="number">4</span>,   <span class="comment">/* sign extend to byte */</span></span><br><span class="line">    SXTH = <span class="number">5</span>,   <span class="comment">/* sign extend to half word */</span></span><br><span class="line">    SXTW = <span class="number">6</span>,   <span class="comment">/* sign extend to word */</span></span><br><span class="line">    SXTX = <span class="number">7</span>,   <span class="comment">/* sign extend to 64bit */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对于<code>Shift</code>，是作为对应了位移和旋转操作(逻辑位移、算数位移、旋转以及条件性移动指令)：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Shift</span> : <span class="type">uint8_t</span> &#123;</span><br><span class="line">    NO_SHIFT = <span class="number">0xFF</span>,</span><br><span class="line">    LSL = <span class="number">0x0</span>,  <span class="comment">// 逻辑左移</span></span><br><span class="line">    LSR = <span class="number">0x1</span>,  <span class="comment">// 逻辑右移</span></span><br><span class="line">    ASR = <span class="number">0x2</span>,  <span class="comment">// 算术右移</span></span><br><span class="line">    ROR = <span class="number">0x3</span>,  <span class="comment">// 旋转</span></span><br><span class="line">    MSL = <span class="number">0x4</span>,  <span class="comment">// 条件性移动</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对于<code>AddrMode</code>来说，<strong>用于内存访问指令的寻址模式</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span>  <span class="title class_">AddrMode</span> &#123;</span><br><span class="line">    OFFSET,</span><br><span class="line">    PREINDEX,</span><br><span class="line">    POSTINDEX</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>OFFSET</code>：仅计算偏移量，但不更新基地址寄存器。</li>
<li><code>PREINDEX</code>：在访问之前计算偏移量并更新基地址寄存器。</li>
<li><code>POSTINDEX</code>：在访问之后计算偏移量并更新基地址寄存器。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">; OFFSET</span><br><span class="line">LDR X0, [X1, #8]    ; 从地址 X1 + 8 处加载数据到 X0 寄存器</span><br><span class="line">; PREINDEX</span><br><span class="line">LDR X0, [X1, #8]!   ; 从地址 X1 + 8 处加载数据到 X0 寄存器，并更新 X1 为 X1 + 8</span><br><span class="line">; POSTINDEX</span><br><span class="line">LDR X0, [X1], #8    ; 从地址 X1 处加载数据到 X0 寄存器，并在加载后将 X1 更新为 X1 + 8</span><br></pre></td></tr></table></figure>

<p>由这些组合而成的<code>Operand</code>能够为之后<code>Assembler</code>提供相应的操作数，这样能够避免过多冗余数据的产生。</p>
<h4 id="Data-Operand"><a href="#Data-Operand" class="headerlink" title="Data Operand"></a>Data Operand</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Operand</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Operand</span>(Immediate imm)</span><br><span class="line">        : <span class="built_in">reg_</span>(RegisterId::INVALID_REG), <span class="built_in">extend_</span>(Extend::NO_EXTEND), <span class="built_in">shift_</span>(Shift::NO_SHIFT),</span><br><span class="line">          <span class="built_in">shiftAmount_</span>(<span class="number">0</span>), <span class="built_in">immediate_</span>(imm) &#123;&#125;</span><br><span class="line">    <span class="built_in">Operand</span>(Register reg, Shift shift = Shift::LSL, <span class="type">uint8_t</span> shift_amount = <span class="number">0</span>)</span><br><span class="line">        : <span class="built_in">reg_</span>(reg), <span class="built_in">extend_</span>(Extend::NO_EXTEND), <span class="built_in">shift_</span>(shift), <span class="built_in">shiftAmount_</span>(shift_amount), <span class="built_in">immediate_</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">Operand</span>(Register reg, Extend extend, <span class="type">uint8_t</span> shiftAmount = <span class="number">0</span>)</span><br><span class="line">        : <span class="built_in">reg_</span>(reg), <span class="built_in">extend_</span>(extend), <span class="built_in">shift_</span>(Shift::NO_SHIFT), <span class="built_in">shiftAmount_</span>(shiftAmount), <span class="built_in">immediate_</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Operand</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">IsImmediate</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">IsShifted</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">IsExtended</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> Register <span class="title">Reg</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> Shift <span class="title">GetShiftOption</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> Extend <span class="title">GetExtendOption</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">uint8_t</span> <span class="title">GetShiftAmount</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int64_t</span> <span class="title">ImmediateValue</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> Immediate <span class="title">GetImmediate</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Register reg_;</span><br><span class="line">    Extend  extend_;</span><br><span class="line">    Shift  shift_;</span><br><span class="line">    <span class="type">uint8_t</span>  shiftAmount_;</span><br><span class="line">    Immediate immediate_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Memory-Operand"><a href="#Memory-Operand" class="headerlink" title="Memory Operand"></a>Memory Operand</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MemoryOperand</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MemoryOperand</span>(Register base, Register offset, Extend extend, <span class="type">uint8_t</span>  shiftAmount = <span class="number">0</span>)</span><br><span class="line">        : <span class="built_in">base_</span>(base), <span class="built_in">offsetReg_</span>(offset), <span class="built_in">offsetImm_</span>(<span class="number">0</span>), <span class="built_in">addrmod_</span>(AddrMode::OFFSET),</span><br><span class="line">          <span class="built_in">extend_</span>(extend), <span class="built_in">shift_</span>(Shift::NO_SHIFT), <span class="built_in">shiftAmount_</span>(shiftAmount) &#123;&#125;</span><br><span class="line">    <span class="built_in">MemoryOperand</span>(Register base, Register offset, Shift shift = Shift::NO_SHIFT, <span class="type">uint8_t</span>  shiftAmount = <span class="number">0</span>)</span><br><span class="line">        : <span class="built_in">base_</span>(base), <span class="built_in">offsetReg_</span>(offset), <span class="built_in">offsetImm_</span>(<span class="number">0</span>), <span class="built_in">addrmod_</span>(AddrMode::OFFSET),</span><br><span class="line">          <span class="built_in">extend_</span>(Extend::NO_EXTEND), <span class="built_in">shift_</span>(shift), <span class="built_in">shiftAmount_</span>(shiftAmount) &#123;&#125;</span><br><span class="line">    <span class="built_in">MemoryOperand</span>(Register base, <span class="type">int64_t</span> offset, AddrMode addrmod = AddrMode::OFFSET)</span><br><span class="line">        : <span class="built_in">base_</span>(base), <span class="built_in">offsetReg_</span>(RegisterId::INVALID_REG), <span class="built_in">offsetImm_</span>(offset), <span class="built_in">addrmod_</span>(addrmod),</span><br><span class="line">          <span class="built_in">extend_</span>(Extend::NO_EXTEND), <span class="built_in">shift_</span>(Shift::NO_SHIFT), <span class="built_in">shiftAmount_</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">MemoryOperand</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Register <span class="title">GetRegBase</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsImmediateOffset</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">Immediate <span class="title">GetImmediate</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">AddrMode <span class="title">GetAddrMode</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">Extend <span class="title">GetExtendOption</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">Shift <span class="title">GetShiftOption</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">uint8_t</span> <span class="title">GetShiftAmount</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">Register <span class="title">GetRegisterOffset</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Register base_;</span><br><span class="line">    Register offsetReg_;</span><br><span class="line">    Immediate offsetImm_;</span><br><span class="line">    AddrMode addrmod_;</span><br><span class="line">    Extend extend_;</span><br><span class="line">    Shift shift_;</span><br><span class="line">    <span class="type">uint8_t</span> shiftAmount_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里与<code>Operand</code>不同的是，因为<code>aarch64</code>是以基址作为跳转的，因此我们需要一个基址寄存器和一个偏移量(这个偏移量可能是寄存器值也可能是立即数值)。还需要通过<code>AddrMode</code>来判断具体的寻址模式。</p>
<h3 id="Assembler-Implement"><a href="#Assembler-Implement" class="headerlink" title="Assembler Implement"></a>Assembler Implement</h3><p>在前面讲解<code>assembler.h</code>时，我有提到：<strong>所有的实际架构的汇编都是基于<code>Assembler</code>的，因此，我们实际上是要对<code>buffer_</code>进行操作，对数据进行处理后，写入实际的汇编对应的机器码</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AssemblerAarch64</span> : <span class="keyword">public</span> Assembler;</span><br></pre></td></tr></table></figure>

<p>这里还需要注意一点，在<code>ArkTS</code>实现<code>aarch64</code>时，使用了宏来确定了指令集的字段、位宽和掩码等数据：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DECL_FIELDS_IN_INSTRUCTION(INSTNAME, FIELD_NAME, HIGHBITS, LOWBITS) \</span></span><br><span class="line"><span class="meta">static const uint32_t INSTNAME##_##FIELD_NAME##_HIGHBITS = HIGHBITS;  \</span></span><br><span class="line"><span class="meta">static const uint32_t INSTNAME##_##FIELD_NAME##_LOWBITS = LOWBITS;    \</span></span><br><span class="line"><span class="meta">static const uint32_t INSTNAME##_##FIELD_NAME##_WIDTH = ((HIGHBITS - LOWBITS) + 1); \</span></span><br><span class="line"><span class="meta">static const uint32_t INSTNAME##_##FIELD_NAME##_MASK = (((1 &lt;&lt; INSTNAME##_##FIELD_NAME##_WIDTH) - 1) &lt;&lt; LOWBITS);</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DECL_INSTRUCTION_FIELDS(V)  \</span></span><br><span class="line"><span class="meta">    COMMON_REGISTER_FIELD_LIST(V)   \</span></span><br><span class="line"><span class="meta">    LDP_AND_STP_FIELD_LIST(V)       \</span></span><br><span class="line"><span class="meta">    LDR_AND_STR_FIELD_LIST(V)       \</span></span><br><span class="line"><span class="meta">    MOV_WIDE_FIELD_LIST(V)          \</span></span><br><span class="line"><span class="meta">    BITWISE_OP_FIELD_LIST(V)        \</span></span><br><span class="line"><span class="meta">    ADD_SUB_FIELD_LIST(V)           \</span></span><br><span class="line"><span class="meta">    COMPARE_OP_FIELD_LIST(V)        \</span></span><br><span class="line"><span class="meta">    BRANCH_FIELD_LIST(V)            \</span></span><br><span class="line"><span class="meta">    BRK_FIELD_LIST(V)</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COMMON_REGISTER_FIELD_LIST(V)   \</span></span><br><span class="line"><span class="meta">    V(COMMON_REG, Rd, 4, 0)             \</span></span><br><span class="line"><span class="meta">    V(COMMON_REG, Rn, 9, 5)             \</span></span><br><span class="line"><span class="meta">    V(COMMON_REG, Rm, 20, 16)           \</span></span><br><span class="line"><span class="meta">    V(COMMON_REG, Rt, 4, 0)             \</span></span><br><span class="line"><span class="meta">    V(COMMON_REG, Rt2, 14, 10)          \</span></span><br><span class="line"><span class="meta">    V(COMMON_REG, Sf, 31, 31)</span></span><br></pre></td></tr></table></figure>

<h4 id="Add-Sub"><a href="#Add-Sub" class="headerlink" title="Add &amp;&amp; Sub"></a>Add &amp;&amp; Sub</h4><p>在<code>aarch64</code>中，<code>add</code>和<code>sub</code>是一组几乎相同的指令。因此我们主要针对<code>add</code>进行讲解。<code>add</code>有两种类型：<code>add</code>和<code>adds</code>(我们不考虑<code>addg</code>的实现)。其中，<code>add</code>和<code>adds</code>各有三种情况：<code>extend register</code>、<code>immediate</code>和<code>shifted register</code>。</p>
<h5 id="add-extend-register"><a href="#add-extend-register" class="headerlink" title="add(extend register)"></a>add(extend register)</h5><p><code>Add(extended register)</code><strong>指令将一个寄存器值和一个符号或零扩展的寄存器值相加，并可以选择进行左移，然后将结果写入目标寄存器</strong>。由<code>&lt;Rm&gt;</code>寄存器扩展而来的参数可以是字节(byte)、半字(halfword)、字(word)或双字(doubleword)。</p>
<p><img src="https://hexo-pirctures.oss-cn-chengdu.aliyuncs.com/imgs202407041036158.png" alt="add extended register"></p>
<p>从<code>sf</code>位可以判断指令的数据位宽：</p>
<ul>
<li>如果$sf &#x3D; 0$，则表示$32bits$:<ul>
<li><code>ADD &lt;Wd|WSP&gt;, &lt;Wn|WSP&gt;, &lt;Wm&gt;&#123;, &lt;extend&gt; &#123;#&lt;amount&gt;&#125;&#125;</code></li>
</ul>
</li>
<li>如果$sf &#x3D; 1$，则表示$64bits$:<ul>
<li><code>ADD &lt;Xd|SP&gt;, &lt;Xn|SP&gt;, &lt;R&gt;&lt;m&gt;&#123;, &lt;extend&gt; &#123;#&lt;amount&gt;&#125;&#125;</code></li>
</ul>
</li>
</ul>
<p>对于<code>*d</code>而言，则为作为目的寄存器，而<code>*n</code>是第一个源寄存器。而<code>*m</code>自然就是第二个源寄存器。对于在$64bits$下的指令格式而言，<code>&lt;R&gt;</code>用于表示寄存器前缀，<code>&lt;m&gt;</code>表示其寄存器号：</p>
<table>
<thead>
<tr>
<th align="center"><code>&lt;R&gt;</code></th>
<th align="center">code</th>
</tr>
</thead>
<tbody><tr>
<td align="center">W</td>
<td align="center">option &#x3D; 00x</td>
</tr>
<tr>
<td align="center">W</td>
<td align="center">option &#x3D; 010</td>
</tr>
<tr>
<td align="center">X</td>
<td align="center">option &#x3D; x11</td>
</tr>
<tr>
<td align="center">W</td>
<td align="center">option &#x3D; 10x</td>
</tr>
<tr>
<td align="center">W</td>
<td align="center">option &#x3D; 110</td>
</tr>
</tbody></table>
<p>对于<code>&lt;extend&gt;</code>而言，则是和<code>Extend</code>这一实现有关，如果有需要请自行向上检索<code>Extend</code>或查阅相关手册。</p>
<p>如果<code>Rd</code>或<code>Rn</code>寄存器为$11111$即<code>WSP</code>时，当指令为$32bits$时，且$option &#x3D; 010$，则以<code>LSL</code>作为扩展方式；如果为$64bits$，且$option &#x3D; 011$，则以<code>LSL</code>作为扩展方式。但如果$imm3 &#x3D; 000$时，其可以被省略，否则其他情况下<code>&lt;extend&gt;</code>是必须的；且在$option &#x3D; 010$时($32bits$)，还需以<code>UXTW</code>方式扩展；在$option &#x3D; 011$时(64bits)，以<code>UXTW</code>方式扩展。</p>
<p><code>&lt;amount&gt;</code>与<code>imm3</code>字段有关，其用于左移的适当的偏移量，范围在$0 - 4$中(默认为$0$)。如果<code>&lt;extend&gt;</code>字段不存在，那么<code>&lt;amount&gt;</code>也就不存在；如果<code>&lt;extend&gt;</code>为<code>LSL</code>，那么<code>&lt;amount&gt;</code>就必须存在；如果<code>&lt;extend&gt;</code>存在但不为<code>LSL</code>，那么<code>&lt;amount&gt;</code>就是一个可选择的选项。</p>
<h5 id="add-immediate"><a href="#add-immediate" class="headerlink" title="add(immediate)"></a>add(immediate)</h5><p><code>add(immediate)</code>添加一个寄存器值和一个可选择性位移的立即数值，并写入到目的寄存器中。该指令可以用于<code>MOV(to/from SP)</code>的别名。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ADD &lt;Wd|WSP&gt;, &lt;Wn|WSP&gt;, #&lt;imm&gt;&#123;, &lt;shift&gt;&#125; ; 32-bits</span><br><span class="line">ADD &lt;Xd|SP&gt;, &lt;Xn|SP&gt;, #&lt;imm&gt;&#123;, &lt;shift&gt;&#125;   ; 64-bits</span><br></pre></td></tr></table></figure>

<p><img src="https://hexo-pirctures.oss-cn-chengdu.aliyuncs.com/imgs202407041138935.png" alt="add immediate"></p>
<p>当$sh &#x3D; 0$且$imm12 &#x3D; 0$，以及$R_n &#x3D; SP$和$R_d &#x3D; SP$时，可以用作<code>MOV</code>的一个别名：</p>
<p><img src="https://hexo-pirctures.oss-cn-chengdu.aliyuncs.com/imgs202407041142177.png" alt="add mov"></p>
<p>对于之前相同的字段名，这里不做过多介绍。<code>imm12</code>和<code>imm3</code>类似，不过这里的<code>imm12</code>是立即数数据，用于计算，其范围在$0 - 4095$之间。</p>
<p>对于<code>&lt;shift&gt;</code>字段，则是会默认对<code>&lt;imm12&gt;</code>字段进行<code>LSL #0</code>的操作。如果$sh &#x3D; 1$，则会进行<code>LSL #12</code>的操作(即符号扩展)。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> sh of</span><br><span class="line">  when <span class="string">&#x27;0&#x27;</span> imm = <span class="built_in">ZeroExtend</span>(imm12, datasize);</span><br><span class="line">  when <span class="string">&#x27;1&#x27;</span> imm = <span class="built_in">ZeroExtend</span>(imm12:<span class="built_in">Zeros</span>(<span class="number">12</span>), datasize);</span><br></pre></td></tr></table></figure>

<h5 id="add-shifted-register"><a href="#add-shifted-register" class="headerlink" title="add(shifted register)"></a>add(shifted register)</h5><p><code>add(shifted register)</code>添加一个寄存器值和一个可选择性位移的寄存器值，并写入到目的寄存器中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ADD &lt;Wd&gt;, &lt;Wn&gt;, &lt;Wm&gt;&#123;, &lt;shift&gt; #&lt;amount&gt;&#125; ; 32-bits</span><br><span class="line">ADD &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;&#123;, &lt;shift&gt; #&lt;amount&gt;&#125; ; 64-bits</span><br></pre></td></tr></table></figure>

<p><img src="https://hexo-pirctures.oss-cn-chengdu.aliyuncs.com/imgs202407041156195.png" alt="add(shifted register)"></p>
<p>对于<code>&lt;shift&gt;</code>字段，其会对第二个源寄存器进行处理：</p>
<table>
<thead>
<tr>
<th align="center">type</th>
<th align="center">code</th>
</tr>
</thead>
<tbody><tr>
<td align="center">LSL</td>
<td align="center">shift &#x3D; 00</td>
</tr>
<tr>
<td align="center">LSR</td>
<td align="center">shift &#x3D; 01</td>
</tr>
<tr>
<td align="center">ASR</td>
<td align="center">shift &#x3D; 10</td>
</tr>
</tbody></table>
<p>而<code>&lt;amount&gt;</code>字段则是与<code>imm6</code>字段相关，用于位移的位宽，其范围为$0 - 31$，默认为$0$。</p>
<h5 id="adds"><a href="#adds" class="headerlink" title="adds"></a>adds</h5><p>对于<code>adds</code>指令而言，也有三种情况：<code>adds(extended register)</code>、<code>adds(immediate)</code>和<code>adds(shifted register)</code>。与上面的<code>add</code>不同的只有其中的<code>&lt;S&gt;</code>标志，<strong>以及执行加法操作，同时更新条件标志</strong>($N$, $Z$, $C$, $V$)。其余均无变化。</p>
<p><img src="https://hexo-pirctures.oss-cn-chengdu.aliyuncs.com/imgs202407041216169.png" alt="adds"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">; adds(extend register)</span><br><span class="line">ADDS &lt;Wd&gt;, &lt;Wn|WSP&gt;, &lt;Wm&gt;&#123;, &lt;extend&gt; &#123;#&lt;amount&gt;&#125;&#125;   ; 32-bits</span><br><span class="line">ADDS &lt;Xd&gt;, &lt;Xn|SP&gt;, &lt;R&gt;&lt;m&gt;&#123;, &lt;extend&gt; &#123;#&lt;amount&gt;&#125;&#125;  ; 64-bits</span><br><span class="line"></span><br><span class="line">; adds(immediate)</span><br><span class="line">ADDS &lt;Wd&gt;, &lt;Wn|WSP&gt;, #&lt;imm&gt;&#123;, &lt;shift&gt;&#125;</span><br><span class="line">ADDS &lt;Xd&gt;, &lt;Xn|SP&gt;, #&lt;imm&gt;&#123;, &lt;shift&gt;&#125;</span><br><span class="line"></span><br><span class="line">; adds(shifted register)</span><br><span class="line">ADDS &lt;Wd&gt;, &lt;Wn&gt;, &lt;Wm&gt;&#123;, &lt;shift&gt; #&lt;amount&gt;&#125;</span><br><span class="line">ADDS &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;&#123;, &lt;shift&gt; #&lt;amount&gt;&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">condition</th>
<th align="center">meaning</th>
</tr>
</thead>
<tbody><tr>
<td align="center">N(Negative)</td>
<td align="center">$result \lt 0$</td>
</tr>
<tr>
<td align="center">Z(Zero)</td>
<td align="center">$result &#x3D; 0$</td>
</tr>
<tr>
<td align="center">C(Carry)</td>
<td align="center">carry</td>
</tr>
<tr>
<td align="center">V(Overflow)</td>
<td align="center">over flow</td>
</tr>
</tbody></table>
<p>还有一点差距的是：</p>
<ul>
<li><code>adds(extended register)</code>可用作<code>CMN(extended register)</code>的别名</li>
<li><code>adds(immediate)</code>可用作<code>CMN(immediate)</code>的别名</li>
<li><code>adds(shifted register)</code>可用作<code>CMN(shifted register)</code>的别名</li>
</ul>
<h5 id="add-code"><a href="#add-code" class="headerlink" title="add code"></a>add code</h5><p>首先，我们通过上面所说的宏定义，给出<code>add</code>指令集对应的字段和位宽。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ADD_SUB_FIELD_LIST(V)           \</span></span><br><span class="line"><span class="meta">    V(ADD_SUB, S, 29, 29)               \</span></span><br><span class="line"><span class="meta">    V(ADD_SUB, Sh, 22, 22)              \</span></span><br><span class="line"><span class="meta">    V(ADD_SUB, Imm12, 21, 10)           \</span></span><br><span class="line"><span class="meta">    V(ADD_SUB, Shift, 23, 22)           \</span></span><br><span class="line"><span class="meta">    V(ADD_SUB, ShiftAmount, 15, 10)     \</span></span><br><span class="line"><span class="meta">    V(ADD_SUB, ExtendOption, 15, 13)    \</span></span><br><span class="line"><span class="meta">    V(ADD_SUB, ExtendShift, 12, 10)</span></span><br></pre></td></tr></table></figure>

<p>因为<code>add</code>和<code>sub</code>这两个指令集相差无几，所以我们将这两个指令集的字段和处理逻辑同放在<code>AddSubImm</code>和<code>AddSubReg</code>中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AssemblerAarch64::AddSubImm</span><span class="params">(AddSubOpCode op, <span class="type">const</span> Register &amp;rd, <span class="type">const</span> Register &amp;rn, <span class="type">bool</span> setFlags, <span class="type">uint64_t</span> imm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ASSERT</span>(<span class="built_in">IsAddSubImm</span>(imm));</span><br><span class="line">    <span class="type">uint32_t</span> shift = <span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">uint64_t</span> IMM12_MASK = (<span class="number">1</span> &lt;&lt; ADD_SUB_Imm12_WIDTH) - <span class="number">1</span>;</span><br><span class="line">    <span class="type">uint64_t</span> imm12 = imm &amp; (~IMM12_MASK);</span><br><span class="line">    <span class="keyword">if</span> (imm12 != <span class="number">0</span>) &#123;</span><br><span class="line">        shift = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        imm12 = imm;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">uint32_t</span> flags_field = ((setFlags ? <span class="number">1</span> : <span class="number">0</span>) &lt;&lt; ADD_SUB_S_LOWBITS) &amp; ADD_SUB_S_MASK;</span><br><span class="line">    <span class="type">uint32_t</span> imm_field = (imm12 &lt;&lt; ADD_SUB_Imm12_LOWBITS) &amp; ADD_SUB_Imm12_MASK;</span><br><span class="line">    <span class="type">uint32_t</span> shift_field = (shift &lt;&lt; ADD_SUB_Sh_LOWBITS) &amp; ADD_SUB_Sh_MASK;</span><br><span class="line">    <span class="type">uint32_t</span> code = <span class="built_in">Sf</span>(!rd.<span class="built_in">IsW</span>()) | op | flags_field | shift_field | imm_field | <span class="built_in">Rd</span>(rd.<span class="built_in">GetId</span>()) | <span class="built_in">Rn</span>(rn.<span class="built_in">GetId</span>());</span><br><span class="line">    <span class="built_in">EmitU32</span>(code);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于<code>add(immediate)</code>的处理而言，我们需要对是否需要进行扩展和立即数进行提取，然后移动到对应的位上即可。<code>setFlags</code>用于判断是<code>add</code>还是<code>adds</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AssemblerAarch64::AddSubReg</span><span class="params">(AddSubOpCode op, <span class="type">const</span> Register &amp;rd, <span class="type">const</span> Register &amp;rn,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="type">bool</span> setFlags, <span class="type">const</span> Operand &amp;operand)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> flags_field = ((setFlags ? <span class="number">1</span> : <span class="number">0</span>) &lt;&lt; ADD_SUB_S_LOWBITS) &amp; ADD_SUB_S_MASK;</span><br><span class="line">    <span class="type">uint32_t</span> code = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (operand.<span class="built_in">IsShifted</span>()) &#123;</span><br><span class="line">        <span class="type">uint32_t</span> shift_field = ((operand.<span class="built_in">GetShiftOption</span>()) &lt;&lt; ADD_SUB_Shift_LOWBITS) &amp; ADD_SUB_Shift_MASK;</span><br><span class="line">        <span class="type">uint32_t</span> shift_amount = ((operand.<span class="built_in">GetShiftAmount</span>()) &lt;&lt; ADD_SUB_ShiftAmount_LOWBITS) &amp; ADD_SUB_ShiftAmount_MASK;</span><br><span class="line">        <span class="built_in">ASSERT</span>((op == ADD_Shift) | (op == SUB_Shift));</span><br><span class="line">        code = <span class="built_in">Sf</span>(!rd.<span class="built_in">IsW</span>()) | op | flags_field | shift_field | <span class="built_in">Rm</span>(operand.<span class="built_in">Reg</span>().<span class="built_in">GetId</span>()) |</span><br><span class="line">                  shift_amount | <span class="built_in">Rn</span>(rn.<span class="built_in">GetId</span>()) | <span class="built_in">Rd</span>(rd.<span class="built_in">GetId</span>());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">ASSERT</span>((op == ADD_Extend) | (op == SUB_Extend));</span><br><span class="line">        <span class="type">uint32_t</span> extend_field =</span><br><span class="line">            (operand.<span class="built_in">GetExtendOption</span>() &lt;&lt; ADD_SUB_ExtendOption_LOWBITS) &amp; ADD_SUB_ExtendOption_MASK;</span><br><span class="line">        <span class="type">uint32_t</span> extend_shift = (operand.<span class="built_in">GetShiftAmount</span>() &lt;&lt; ADD_SUB_ExtendShift_LOWBITS) &amp; ADD_SUB_ExtendShift_MASK;</span><br><span class="line">        code = <span class="built_in">Sf</span>(!rd.<span class="built_in">IsW</span>()) | op | flags_field | <span class="built_in">Rm</span>(operand.<span class="built_in">Reg</span>().<span class="built_in">GetId</span>()) | extend_field |</span><br><span class="line">                  extend_shift | <span class="built_in">Rn</span>(rn.<span class="built_in">GetId</span>()) | <span class="built_in">Rd</span>(rd.<span class="built_in">GetId</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">EmitU32</span>(code);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里同时处理了<code>add(extend register)</code>和<code>add(shifted register)</code>这两种情况，可以看见，实际上就是将对应字段数据处理到真实机器码字段的对应位置即可。</p>
<h4 id="CMP"><a href="#CMP" class="headerlink" title="CMP"></a>CMP</h4><h5 id="cmp"><a href="#cmp" class="headerlink" title="cmp"></a>cmp</h5><p>在<code>aarch64</code>中，<code>CMP</code>有三种类型，其都可以与<code>SUBS</code>等价。</p>
<p><img src="https://hexo-pirctures.oss-cn-chengdu.aliyuncs.com/imgs202407041505225.png" alt="cmp"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">; cmp(extend register)</span><br><span class="line">CMP &lt;Wn|WSP&gt;, &lt;Wm&gt;&#123;, &lt;extend&gt; &#123;#&lt;amount&gt;&#125;&#125;  ; 32-bits</span><br><span class="line">  equals SUBS WZR, &lt;Wn|WSP&gt;, &lt;Wm&gt;&#123;, &lt;extend&gt; &#123;#&lt;amount&gt;&#125;&#125;</span><br><span class="line">CMP &lt;Xn|SP&gt;, &lt;R&gt;&lt;m&gt;&#123;, &lt;extend&gt; &#123;#&lt;amount&gt;&#125;&#125; ; 64-bits</span><br><span class="line">  equals SUBS XZR, &lt;Xn|SP&gt;, &lt;R&gt;&lt;m&gt;&#123;, &lt;extend&gt; &#123;#&lt;amount&gt;&#125;&#125;</span><br><span class="line">  </span><br><span class="line">; cmp(immediate)</span><br><span class="line">CMP &lt;Wn|WSP&gt;, #&lt;imm&gt;&#123;, &lt;shift&gt;&#125; ; 32-bits</span><br><span class="line">  equals SUBS WZR, &lt;Wn|WSP&gt;, #&lt;imm&gt; &#123;, &lt;shift&gt;&#125;</span><br><span class="line">CMP &lt;Xn|SP&gt;, #&lt;imm&gt;&#123;, &lt;shift&gt;&#125;  ; 64-bits</span><br><span class="line">  equals SUBS XZR, &lt;Xn|SP&gt;, #&lt;imm&gt; &#123;, &lt;shift&gt;&#125;</span><br><span class="line">  </span><br><span class="line">; cmp(shifted register)</span><br><span class="line">CMP &lt;Wn&gt;, &lt;Wm&gt;&#123;, &lt;shift&gt; #&lt;amount&gt;&#125; ; 32-bits</span><br><span class="line">  equals SUBS WZR, &lt;Wn&gt;, &lt;Wm&gt; &#123;, &lt;shift&gt; #&lt;amount&gt;&#125;</span><br><span class="line">CMP &lt;Xn&gt;, &lt;Xm&gt;&#123;, &lt;shift&gt; #&lt;amount&gt;&#125; ; 64-bits</span><br><span class="line">  equals SUBS XZR, &lt;Xn&gt;, &lt;Xm&gt; &#123;, &lt;shift&gt; #&lt;amount&gt;&#125;</span><br></pre></td></tr></table></figure>

<h5 id="CBZ"><a href="#CBZ" class="headerlink" title="CBZ"></a>CBZ</h5><p><code>CBZ</code><strong>将寄存器中的值与零进行比较，如果比较结果相等，则条件跳转到一个与当前程序计数器(PC)相对偏移的标签处。该指令提示这不是一个子程序调用或返回。这条指令不会影响条件标志</strong>。</p>
<p><img src="https://hexo-pirctures.oss-cn-chengdu.aliyuncs.com/imgs202407041517189.png" alt="cbz"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CBZ &lt;Wt&gt;, &lt;label&gt; ; 32-bits</span><br><span class="line">CBZ &lt;Xt&gt;, &lt;label&gt; ; 64-bits</span><br></pre></td></tr></table></figure>

<p>对于<code>CBZ</code>而言，最简单的实现就是直接跳转到立即数地址处，但是我们为了更加方便，还增加了一个<code>Label</code>的重载，通过<code>Label</code>计算其偏移量，然后进行跳转:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AssemblerAarch64::Cbz</span><span class="params">(<span class="type">const</span> Register &amp;rt, Label *label)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int32_t</span> offsetImm = <span class="built_in">LinkAndGetInstOffsetToLabel</span>(label);</span><br><span class="line">    <span class="comment">// 2 : 2 means 4 bytes aligned.</span></span><br><span class="line">    offsetImm &gt;&gt;= <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">Cbz</span>(rt, offsetImm);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AssemblerAarch64::Cbz</span><span class="params">(<span class="type">const</span> Register &amp;rt, <span class="type">int32_t</span> imm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> code = <span class="built_in">Sf</span>(!rt.<span class="built_in">IsW</span>()) | BranchOpCode::CBZ | <span class="built_in">BranchImm19</span>(imm) | rt.<span class="built_in">GetId</span>();</span><br><span class="line">    <span class="built_in">EmitU32</span>(code);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="CBNZ"><a href="#CBNZ" class="headerlink" title="CBNZ"></a>CBNZ</h5><p><code>CBNZ</code><strong>将寄存器中的值与零进行比较，如果比较结果不相等，则条件跳转到一个与当前程序计数器(PC)相对偏移的标签处。该指令提示这不是一个子程序调用或返回。这条指令不会影响条件标志</strong>。</p>
<p><img src="https://hexo-pirctures.oss-cn-chengdu.aliyuncs.com/imgs202407041527765.png" alt="cbnz"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CBNZ &lt;Wt&gt;, &lt;label&gt; ; 32-bits</span><br><span class="line">CBNZ &lt;Xt&gt;, &lt;label&gt; ; 64-bits</span><br></pre></td></tr></table></figure>

<p><code>CBNZ</code>的代码实现和<code>CBZ</code>几乎相同：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AssemblerAarch64::Cbnz</span><span class="params">(<span class="type">const</span> Register &amp;rt, Label *label)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int32_t</span> offsetImm = <span class="built_in">LinkAndGetInstOffsetToLabel</span>(label);</span><br><span class="line">    <span class="comment">// 2 : 2 means 4 bytes aligned.</span></span><br><span class="line">    offsetImm &gt;&gt;= <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">Cbnz</span>(rt, offsetImm);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AssemblerAarch64::Cbnz</span><span class="params">(<span class="type">const</span> Register &amp;rt, <span class="type">int32_t</span> imm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> code = <span class="built_in">Sf</span>(!rt.<span class="built_in">IsW</span>()) | BranchOpCode::CBNZ | <span class="built_in">BranchImm19</span>(imm) | rt.<span class="built_in">GetId</span>();</span><br><span class="line">    <span class="built_in">EmitU32</span>(code);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Branch"><a href="#Branch" class="headerlink" title="Branch"></a>Branch</h4><h5 id="B"><a href="#B" class="headerlink" title="B"></a>B</h5><p><code>B</code>会<strong>引起一个无条件跳转到一个与程序计数器(PC)相对偏移的标签，并提示这不是一个子程序调用或返回</strong>。</p>
<p><img src="https://hexo-pirctures.oss-cn-chengdu.aliyuncs.com/imgs202407041544668.png" alt="b"></p>
<p>为了支持度更高，我们也和<code>CMP</code>一样，针对<code>Label</code>做了一个重载：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AssemblerAarch64::B</span><span class="params">(Label *label)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int32_t</span> offsetImm = <span class="built_in">LinkAndGetInstOffsetToLabel</span>(label);</span><br><span class="line">    <span class="comment">// 2 : 2 means 4 bytes aligned.</span></span><br><span class="line">    offsetImm &gt;&gt;= <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">B</span>(offsetImm);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AssemblerAarch64::B</span><span class="params">(<span class="type">int32_t</span> imm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> code = BranchOpCode::Branch | ((imm &lt;&lt; BRANCH_Imm26_LOWBITS) &amp; BRANCH_Imm26_MASK);</span><br><span class="line">    <span class="built_in">EmitU32</span>(code);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="B-cond"><a href="#B-cond" class="headerlink" title="B.cond"></a>B.cond</h5><p><code>B.cond</code><strong>根据条件跳转到一个与程序计数器(PC)相对偏移的标签，并提示这不是一个子程序调用或返回</strong>。</p>
<p><img src="https://hexo-pirctures.oss-cn-chengdu.aliyuncs.com/imgs202407041552227.png" alt="B.cond"></p>
<p>对于<code>&lt;cond&gt;</code>而言，可以使用标准的<code>conditions</code>，可以参考上面所实现的<code>Condition</code>或对应的参考手册。</p>
<p>而<code>&lt;label&gt;</code>相对于该指令地址的偏移量在$±1MB$范围内。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AssemblerAarch64::B</span><span class="params">(Condition cond, Label *label)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int32_t</span> offsetImm = <span class="built_in">LinkAndGetInstOffsetToLabel</span>(label);</span><br><span class="line">    <span class="comment">// 2 : 2 means 4 bytes aligned.</span></span><br><span class="line">    offsetImm &gt;&gt;= <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">B</span>(cond, offsetImm);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AssemblerAarch64::B</span><span class="params">(Condition cond, <span class="type">int32_t</span> imm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> code = BranchOpCode::BranchCond | <span class="built_in">BranchImm19</span>(imm) | cond;</span><br><span class="line">    <span class="built_in">EmitU32</span>(code);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Br"><a href="#Br" class="headerlink" title="Br"></a>Br</h5><p><code>Br</code><strong>无条件地跳转到寄存器中的地址，并提示这不是一个子程序返回</strong>。</p>
<p><img src="https://hexo-pirctures.oss-cn-chengdu.aliyuncs.com/imgs202407041605898.png" alt="Br"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AssemblerAarch64::Br</span><span class="params">(<span class="type">const</span> Register &amp;rn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> code = BranchOpCode::BR | <span class="built_in">Rn</span>(rn.<span class="built_in">GetId</span>());</span><br><span class="line">    <span class="built_in">EmitU32</span>(code);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Blr"><a href="#Blr" class="headerlink" title="Blr"></a>Blr</h5><p><code>Blr</code><strong>调用寄存器中的地址处的子程序，并将寄存器<code>X30</code>设置为</strong>$PC+4$。</p>
<p><img src="https://hexo-pirctures.oss-cn-chengdu.aliyuncs.com/imgs202407041613453.png" alt="blr"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AssemblerAarch64::Blr</span><span class="params">(<span class="type">const</span> Register &amp;rn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ASSERT</span>(!rn.<span class="built_in">IsW</span>());</span><br><span class="line">    <span class="type">uint32_t</span> code = CallOpCode::BLR | <span class="built_in">Rn</span>(rn.<span class="built_in">GetId</span>());</span><br><span class="line">    <span class="built_in">EmitU32</span>(code);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Bl"><a href="#Bl" class="headerlink" title="Bl"></a>Bl</h5><p><code>Bl</code><strong>跳转到一个与程序计数器(PC)相对偏移的位置，并将寄存器<code>X30</code>设置为$PC+4$。它提示这是一个子程序调用</strong>。</p>
<p><img src="https://hexo-pirctures.oss-cn-chengdu.aliyuncs.com/imgs202407041618598.png" alt="Bl"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AssemblerAarch64::Bl</span><span class="params">(Label *label)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int32_t</span> offsetImm = <span class="built_in">LinkAndGetInstOffsetToLabel</span>(label);</span><br><span class="line">    <span class="comment">// 2 : 2 means 4 bytes aligned.</span></span><br><span class="line">    offsetImm &gt;&gt;= <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">Bl</span>(offsetImm);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AssemblerAarch64::Bl</span><span class="params">(<span class="type">int32_t</span> imm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> code = CallOpCode::BL | ((imm &lt;&lt; BRANCH_Imm26_LOWBITS) &amp; BRANCH_Imm26_MASK);</span><br><span class="line">    <span class="built_in">EmitU32</span>(code);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="TB"><a href="#TB" class="headerlink" title="TB"></a>TB</h4><h5 id="TBNZ"><a href="#TBNZ" class="headerlink" title="TBNZ"></a>TBNZ</h5><p><code>TBNZ</code><strong>将通用寄存器中的一个位与零进行比较，并在比较结果不等于零时，按PC相对偏移有条件地分支到一个标签。该指令提供一个提示，表示这不是子程序调用或返回。该指令不会影响条件标志</strong>。</p>
<p><img src="https://hexo-pirctures.oss-cn-chengdu.aliyuncs.com/imgs202407051013408.png" alt="TBNZ"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TBNZ &lt;R&gt;&lt;t&gt;, #&lt;imm&gt;, &lt;label&gt;</span><br></pre></td></tr></table></figure>

<p>在这里的<code>&lt;imm&gt;</code>指的是第几位数据，其被$b5:b40$所共同组成。</p>
<p>而<code>&lt;label&gt;</code>和<code>imm14</code>相关，其范围为$+&#x2F;-32KB$</p>
<p>在实际的处理中，我们依旧提供了<code>imm</code>和<code>Label</code>的两个实现版本：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AssemblerAarch64::Tbnz</span><span class="params">(<span class="type">const</span> Register &amp;rt, <span class="type">int32_t</span> bitPos, Label *label)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int32_t</span> offsetImm = <span class="built_in">LinkAndGetInstOffsetToLabel</span>(label);</span><br><span class="line">    <span class="comment">// 2 : 2 means 4 bytes aligned.</span></span><br><span class="line">    offsetImm &gt;&gt;= <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">Tbnz</span>(rt, bitPos, offsetImm);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AssemblerAarch64::Tbnz</span><span class="params">(<span class="type">const</span> Register &amp;rt, <span class="type">int32_t</span> bitPos, <span class="type">int32_t</span> imm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> b5 = (bitPos &lt;&lt; (BRANCH_B5_LOWBITS - <span class="number">5</span>)) &amp; BRANCH_B5_MASK;</span><br><span class="line">    <span class="type">uint32_t</span> b40 = (bitPos &lt;&lt; BRANCH_B40_LOWBITS) &amp; BRANCH_B40_MASK;</span><br><span class="line">    <span class="type">uint32_t</span> imm14 = (imm &lt;&lt;BRANCH_Imm14_LOWBITS) &amp; BRANCH_Imm14_MASK;</span><br><span class="line">    <span class="type">uint32_t</span> code = b5 | BranchOpCode::TBNZ | b40 | imm14 | rt.<span class="built_in">GetId</span>();</span><br><span class="line">    <span class="built_in">EmitU32</span>(code);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="TBZ"><a href="#TBZ" class="headerlink" title="TBZ"></a>TBZ</h5><p><code>TBZ</code><strong>将测试位的值与零进行比较，并在比较结果等于零时，按PC相对偏移有条件地分支到一个标签。该指令提供一个提示，表示这不是子程序调用或返回。该指令不会影响条件标志</strong>。</p>
<p><img src="https://hexo-pirctures.oss-cn-chengdu.aliyuncs.com/imgs202407051019765.png" alt="TBZ"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TBZ &lt;R&gt;&lt;t&gt;, #&lt;imm&gt;, &lt;label&gt;</span><br></pre></td></tr></table></figure>

<p>与<code>TBNZ</code>的实际处理情况相同：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AssemblerAarch64::Tbz</span><span class="params">(<span class="type">const</span> Register &amp;rt, <span class="type">int32_t</span> bitPos, Label *label)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int32_t</span> offsetImm = <span class="built_in">LinkAndGetInstOffsetToLabel</span>(label);</span><br><span class="line">    <span class="comment">// 2 : 2 means 4 bytes aligned.</span></span><br><span class="line">    offsetImm &gt;&gt;= <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">Tbz</span>(rt, bitPos, offsetImm);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AssemblerAarch64::Tbz</span><span class="params">(<span class="type">const</span> Register &amp;rt, <span class="type">int32_t</span> bitPos, <span class="type">int32_t</span> imm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> b5 = (bitPos &lt;&lt; (BRANCH_B5_LOWBITS - <span class="number">5</span>)) &amp; BRANCH_B5_MASK;</span><br><span class="line">    <span class="type">uint32_t</span> b40 = (bitPos &lt;&lt; BRANCH_B40_LOWBITS) &amp; BRANCH_B40_MASK;</span><br><span class="line">    <span class="type">uint32_t</span> imm14 = (imm &lt;&lt; BRANCH_Imm14_LOWBITS) &amp; BRANCH_Imm14_MASK;</span><br><span class="line">    <span class="type">uint32_t</span> code = b5 | BranchOpCode::TBZ | b40 | imm14 | rt.<span class="built_in">GetId</span>();</span><br><span class="line">    <span class="built_in">EmitU32</span>(code);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="TST"><a href="#TST" class="headerlink" title="TST"></a>TST</h4><h5 id="TST-immediate"><a href="#TST-immediate" class="headerlink" title="TST(immediate)"></a>TST(immediate)</h5><p><code>TST(immediate)</code><strong>指令的作用是对两个操作数执行按位与(AND)运算，但不保存结果。相反，它会根据运算结果设置或清除条件标志寄存器中的相关标志位</strong>。</p>
<p><img src="https://hexo-pirctures.oss-cn-chengdu.aliyuncs.com/imgs202407051033270.png" alt="TST(immediate)"></p>
<p>值得注意的是，<code>TST(immediate)</code>的一个假名则是<code>ADDS(immediate)</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">; sf = 0 &amp;&amp; N = 0</span><br><span class="line">TST &lt;Wn&gt;, #&lt;imm&gt;</span><br><span class="line">  equals ANDS WZR, &lt;Wn&gt;, #&lt;imm&gt;</span><br><span class="line">  </span><br><span class="line">; sf = 1</span><br><span class="line">TST &lt;Xn&gt;, #&lt;imm&gt;</span><br><span class="line">  equals ANDS XZR, &lt;Xn&gt;, #&lt;imm&gt;</span><br></pre></td></tr></table></figure>

<p>这里的<code>&lt;imm&gt;</code>需要注意：如果在$32-bits$下，其由$imms:immr$组成；在$64-bits$下由$N:imms:immr$组成。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AssemblerAarch64::Tst</span><span class="params">(<span class="type">const</span> Register &amp;rn, <span class="type">const</span> LogicalImmediate &amp;imm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Ands</span>(<span class="built_in">Register</span>(Zero, rn.<span class="built_in">GetType</span>()), rn, imm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="TST-shifted-register"><a href="#TST-shifted-register" class="headerlink" title="TST(shifted register)"></a>TST(shifted register)</h5><p><code>TST(shifted register)</code><strong>对寄存器值和可选移位的寄存器值执行按位与操作。它根据结果更新条件标志，并丢弃结果</strong>。</p>
<p><img src="https://hexo-pirctures.oss-cn-chengdu.aliyuncs.com/imgs202407051040715.png" alt="TST(shifted register)"></p>
<p>值得注意的是，<code>TST(shifted register)</code>的一个假名则是<code>ADDS(shifted register)</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TST &lt;Wn&gt;, &lt;Wm&gt;&#123;, &lt;shift&gt; #&lt;amount&gt;&#125; ; 32-bits</span><br><span class="line">  equals ANDS WZR, &lt;Wn&gt;, &lt;Wm&gt;&#123;, &lt;shift&gt; #&lt;amount&gt;&#125;</span><br><span class="line"></span><br><span class="line">TST &lt;Xn&gt;, &lt;Xm&gt;&#123;, &lt;shift&gt; #&lt;amount&gt;&#125; ; 64-bits</span><br><span class="line">  equals ANDS XZR, &lt;Xn&gt;, &lt;Xm&gt;&#123;, &lt;shift&gt; #&lt;amount&gt;&#125;</span><br></pre></td></tr></table></figure>

<p>这里的<code>&lt;shift&gt;</code>的可选项为：</p>
<p><img src="https://hexo-pirctures.oss-cn-chengdu.aliyuncs.com/imgs202407051048196.png" alt="shift"></p>
<h4 id="Logic"><a href="#Logic" class="headerlink" title="Logic"></a>Logic</h4><p>对于<code>ArkTS</code>中的<code>aarch64</code>架构的逻辑部分的汇编实现而言，主要分为<code>Orr</code>和<code>And</code>两类。更重要的是，<code>Orr</code>和<code>And</code>的内部实现实际上是十分相似的，因此我们会使用<code>BitWiseOP</code>这样的函数来统一实现其内部逻辑。</p>
<p>对于<code>Orr</code>和<code>And</code>的具体差异主要在<code>opcode</code>上。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">BitwiseOpCode</span> &#123;</span><br><span class="line">    AND_Imm      = <span class="number">0x12000000</span>,</span><br><span class="line">    AND_Shift    = <span class="number">0x0a000000</span>,</span><br><span class="line">    ANDS_Imm     = <span class="number">0x72000000</span>,</span><br><span class="line">    ANDS_Shift   = <span class="number">0x6a000000</span>,</span><br><span class="line">    ORR_Imm      = <span class="number">0x32000000</span>,</span><br><span class="line">    ORR_Shift    = <span class="number">0x2a000000</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对于<code>immediate</code>下的指令，我们只需要直接传入对应的<code>opcode</code>即可，不需要做多余的处理：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AssemblerAarch64::BitWiseOpImm</span><span class="params">(BitwiseOpCode op, <span class="type">const</span> Register &amp;rd, <span class="type">const</span> Register &amp;rn, <span class="type">uint64_t</span> imm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> code = <span class="built_in">Sf</span>(!rd.<span class="built_in">IsW</span>()) | op | imm | <span class="built_in">Rn</span>(rn.<span class="built_in">GetId</span>()) | <span class="built_in">Rd</span>(rd.<span class="built_in">GetId</span>());</span><br><span class="line">    <span class="built_in">EmitU32</span>(code);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而对于<code>shifted</code>的指令，我们就需要通过之前实现的<code>Operand</code>对<code>shift</code>操作进行具体的处理：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AssemblerAarch64::BitWiseOpShift</span><span class="params">(BitwiseOpCode op, <span class="type">const</span> Register &amp;rd, <span class="type">const</span> Register &amp;rn, <span class="type">const</span> Operand &amp;operand)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> shift_field = (operand.<span class="built_in">GetShiftOption</span>() &lt;&lt; BITWISE_OP_Shift_LOWBITS) &amp; BITWISE_OP_Shift_MASK;</span><br><span class="line">    <span class="type">uint32_t</span> shift_amount = (operand.<span class="built_in">GetShiftAmount</span>() &lt;&lt; BITWISE_OP_ShiftAmount_LOWBITS) &amp; BITWISE_OP_ShiftAmount_MASK;</span><br><span class="line">    <span class="type">uint32_t</span> code = <span class="built_in">Sf</span>(!rd.<span class="built_in">IsW</span>()) | op | shift_field | <span class="built_in">Rm</span>(operand.<span class="built_in">Reg</span>().<span class="built_in">GetId</span>()) |</span><br><span class="line">                       shift_amount | <span class="built_in">Rn</span>(rn.<span class="built_in">GetId</span>()) | <span class="built_in">Rd</span>(rd.<span class="built_in">GetId</span>());</span><br><span class="line">    <span class="built_in">EmitU32</span>(code);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的类似于<code>BITWISE_OP_Shift_LOWBITS</code>是通过<code>BITWISE_OP_FIELD_LIST</code>宏实现的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BITWISE_OP_FIELD_LIST(V)            \</span></span><br><span class="line"><span class="meta">    V(BITWISE_OP, N, 22, 22)                \</span></span><br><span class="line"><span class="meta">    V(BITWISE_OP, Immr, 21, 16)             \</span></span><br><span class="line"><span class="meta">    V(BITWISE_OP, Shift, 23, 22)            \</span></span><br><span class="line"><span class="meta">    V(BITWISE_OP, Imms, 15, 10)             \</span></span><br><span class="line"><span class="meta">    V(BITWISE_OP, ShiftAmount, 15, 10)</span></span><br></pre></td></tr></table></figure>

<h5 id="ORR-immediate"><a href="#ORR-immediate" class="headerlink" title="ORR(immediate)"></a>ORR(immediate)</h5><p><code>Orr immediate</code><strong>对一个寄存器值和一个立即数寄存器值进行按位或(包含或)操作，并将结果写入目标寄存器。该指令可用作别名指令</strong><code>MOV(bitmask immediate)</code>。</p>
<p><img src="https://hexo-pirctures.oss-cn-chengdu.aliyuncs.com/imgs202407161552892.png" alt="Orr immediate"></p>
<p>当$Rn &#x3D; 11111$且<code>!MoveWidePreferred(sf, N, imms, immr)</code>时，可以用作<code>Mov(bitmask immediate)</code>的假名。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ORR &lt;Wd|WSP&gt;, &lt;Wn&gt;, #&lt;imm&gt;  ; 32-bits</span><br><span class="line">ORR &lt;Xd|SP&gt;, &lt;Xn&gt;, #&lt;imm&gt;   ; 64-bits</span><br></pre></td></tr></table></figure>

<p>对于<code>&lt;imm&gt;</code>而言，再$32bits$下由<code>imms:immr</code>组成；而$64bits$由<code>N:imms:immr</code>组成。</p>
<h5 id="ORR-shifted-register"><a href="#ORR-shifted-register" class="headerlink" title="ORR(shifted register)"></a>ORR(shifted register)</h5><p><code>Orr(shifted register)</code><strong>对一个寄存器值和一个可选择进行位移的寄存器值进行按位或(包含或)操作，并将结果写入目标寄存器。该指令可用作别名指令</strong><code>MOV(register)</code>。</p>
<p><img src="https://hexo-pirctures.oss-cn-chengdu.aliyuncs.com/imgs202407161557139.png" alt="orr shifted register"></p>
<p>当$shite &#x3D; 00$且$imm6 &#x3D; 000000$且$Rn &#x3D; 11111$时，可以用作<code>Mov(register)</code>的假名。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ORR &lt;Wd&gt;, &lt;Wn&gt;, &lt;Wm&gt;&#123;, &lt;shift&gt; #&lt;amount&gt;&#125; ; 32-bits</span><br><span class="line">ORR &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;&#123;, &lt;shift&gt; #&lt;amount&gt;&#125; ; 64-bits</span><br></pre></td></tr></table></figure>

<h5 id="AND-immediate"><a href="#AND-immediate" class="headerlink" title="AND(immediate)"></a>AND(immediate)</h5><p><code>And(immediate)</code><strong>对一个寄存器值和一个立即数值进行按位与操作，并将结果写入目标寄存器</strong>。</p>
<p><img src="https://hexo-pirctures.oss-cn-chengdu.aliyuncs.com/imgs202407161507612.png" alt="and immediate"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AND &lt;Wd|WSP&gt;, &lt;Wn&gt;, #&lt;imm&gt;  ; 32-bits</span><br><span class="line">AND &lt;Xd|SP&gt;, &lt;Xn&gt;, #&lt;imm&gt;   ; 64-bits</span><br></pre></td></tr></table></figure>

<p>对于<code>&lt;imm&gt;</code>来说，在$32bits$下由<code>imms:immr</code>构成；而$64bits$下由<code>N:imms:immr</code>构成。</p>
<h5 id="AND-shifted-register"><a href="#AND-shifted-register" class="headerlink" title="AND(shifted register)"></a>AND(shifted register)</h5><p><code>And(shifted register)</code><strong>对一个寄存器值和一个可选择进行位移的寄存器值进行按位与操作，并将结果写入目标寄存器</strong>。</p>
<p><img src="https://hexo-pirctures.oss-cn-chengdu.aliyuncs.com/imgs202407161513255.png" alt="and shifted"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AND &lt;Wd&gt;, &lt;Wn&gt;, &lt;Wm&gt;&#123;, &lt;shift&gt; #&lt;amount&gt;&#125; ; 32-bits</span><br><span class="line">AND &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;&#123;, &lt;shift&gt; #&lt;amount&gt;&#125; ; 64-bits</span><br></pre></td></tr></table></figure>

<h5 id="ANDS-immediate"><a href="#ANDS-immediate" class="headerlink" title="ANDS(immediate)"></a>ANDS(immediate)</h5><p><code>Ands immediate</code><strong>对一个寄存器值和一个立即数值进行按位与操作，并将结果写入目标寄存器。它根据结果更新条件标志位。该指令可用作别名指令</strong><code>TST(immediate)</code>。</p>
<p><img src="https://hexo-pirctures.oss-cn-chengdu.aliyuncs.com/imgs202407161523841.png" alt="ands immediate"></p>
<p>当$Rd &#x3D; 11111$时，可以作为<code>TST(immediate)</code>的别名使用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ANDS &lt;Wd&gt;, &lt;Wn&gt;, #&lt;imm&gt; ; 32-bits</span><br><span class="line">ANDS &lt;Xd&gt;, &lt;Xn&gt;, #&lt;imm&gt; ; 64-bits</span><br></pre></td></tr></table></figure>

<p>对于<code>&lt;imm&gt;</code>而言，再$32bits$下由<code>imms:immr</code>组成；而$64bits$由<code>N:imms:immr</code>组成。</p>
<h5 id="ANDS-shifted-register"><a href="#ANDS-shifted-register" class="headerlink" title="ANDS(shifted register)"></a>ANDS(shifted register)</h5><p><code>Ands shifted register</code><strong>对一个寄存器值和一个可选择进行位移的寄存器值进行按位与操作，并将结果写入目标寄存器。它根据结果更新条件标志位。该指令可用作别名指令</strong><code>TST(shifted register)</code>。</p>
<p><img src="https://hexo-pirctures.oss-cn-chengdu.aliyuncs.com/imgs202407161536291.png" alt="ands shifted"></p>
<p>当$Rd &#x3D; 11111$时，可以作为<code>TST(shifted register)</code>的别名使用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ANDS &lt;Wd&gt;, &lt;Wn&gt;, &lt;Wm&gt;&#123;, &lt;shift&gt; #&lt;amount&gt;&#125;  ; 32-bits</span><br><span class="line">ANDS &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;&#123;, &lt;shift&gt; #&lt;amount&gt;&#125;  ; 64-bits</span><br></pre></td></tr></table></figure>

<h4 id="Shift"><a href="#Shift" class="headerlink" title="Shift"></a>Shift</h4><h5 id="LSR-immediate"><a href="#LSR-immediate" class="headerlink" title="LSR(immediate)"></a>LSR(immediate)</h5><p><code>LSR(immediate)</code><strong>将一个寄存器值向右移动固定的位数，移入零位，并将结果写入目标寄存器</strong>。</p>
<p>该指令是<code>UBFM</code>指令的别名。这意味着：</p>
<ul>
<li>在本描述中，编码的命名与<code>UBFM</code>的编码相匹配。</li>
<li><code>UBFM</code>的描述提供了操作伪代码、任何<code>CONSTRAINED UNPREDICTABLE</code>行为和该指令的操作信息。</li>
</ul>
<p><img src="https://hexo-pirctures.oss-cn-chengdu.aliyuncs.com/imgs202407161614990.png" alt="lsr immediate"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LSR &lt;Wd&gt;, &lt;Wn&gt;, #&lt;shift&gt; ; 32-bits</span><br><span class="line">  equals UBFM &lt;Wd&gt;, &lt;Wn&gt;, #&lt;shift&gt;, #31</span><br><span class="line">  when sf == 0 &amp;&amp; N == 0 &amp;&amp; imms == 011111 </span><br><span class="line">  </span><br><span class="line">LSR &lt;Xd&gt;, &lt;Xn&gt;, #&lt;shift&gt; ; 64-bits</span><br><span class="line">  equals UBFM &lt;Xd&gt;, &lt;Xn&gt;, #&lt;shift&gt;, #63</span><br><span class="line">  when sf == 1 &amp;&amp; N == 1 &amp;&amp; imms == 111111 </span><br></pre></td></tr></table></figure>

<h5 id="LSR-register"><a href="#LSR-register" class="headerlink" title="LSR(register)"></a>LSR(register)</h5><p><code>LSR(register)</code><strong>根据一个可变的位数将一个寄存器值右移，移入零位，并将结果写入目标寄存器。第二个源寄存器除以数据大小所得的余数确定了将第一个源寄存器右移的位数</strong>。</p>
<p>该指令是<code>LSRV</code>指令的别名。这意味着：</p>
<ul>
<li>在本描述中，编码的命名与<code>LSRV</code>的编码相匹配。</li>
<li><code>LSRV</code>的描述提供了操作伪代码、任何<code>CONSTRAINED UNPREDICTABLE</code>行为和该指令的操作信息。</li>
</ul>
<p><img src="https://hexo-pirctures.oss-cn-chengdu.aliyuncs.com/imgs202407161618114.png" alt="lsr register"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LSR &lt;Wd&gt;, &lt;Wn&gt;, &lt;Wm&gt;  ; 32-bits</span><br><span class="line">  equals LSRV &lt;Wd&gt;, &lt;Wn&gt;, &lt;Wm&gt;</span><br><span class="line">  when sf == 0 </span><br><span class="line">  </span><br><span class="line">LSR &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;  ; 64-bits</span><br><span class="line">  equals LSRV &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;</span><br><span class="line">  when sf == 1 </span><br></pre></td></tr></table></figure>

<h5 id="LSL-register"><a href="#LSL-register" class="headerlink" title="LSL(register)"></a>LSL(register)</h5><p><code>LSL(register)</code><strong>根据一个可变的位数将一个寄存器值左移，移入零位，并将结果写入目标寄存器。第二个源寄存器除以数据大小所得的余数确定了将第一个源寄存器左移的位数</strong>。</p>
<p>该指令是<code>LSLV</code>指令的别名。这意味着：</p>
<ul>
<li>在本描述中，编码的命名与<code>LSLV</code>的编码相匹配。</li>
<li><code>LSLV</code>的描述提供了操作伪代码、任何<code>CONSTRAINED UNPREDICTABLE</code>行为和该指令的操作信息</li>
</ul>
<p><img src="https://hexo-pirctures.oss-cn-chengdu.aliyuncs.com/imgs202407161622992.png" alt="lsl register"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LSL &lt;Wd&gt;, &lt;Wn&gt;, &lt;Wm&gt;  ; 32-bits</span><br><span class="line">  equals LSRV &lt;Wd&gt;, &lt;Wn&gt;, &lt;Wm&gt;</span><br><span class="line">  when sf == 0 </span><br><span class="line">  </span><br><span class="line">LSL &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;  ; 64-bits</span><br><span class="line">  equals LSRV &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;</span><br><span class="line">  when sf == 1 </span><br></pre></td></tr></table></figure>

<h5 id="UBFM"><a href="#UBFM" class="headerlink" title="UBFM"></a>UBFM</h5><p><code>Unsigned Bitfield Move</code><strong>通常通过其别名访问，这些别名在反汇编时始终优先选择</strong>。</p>
<ul>
<li>如果$imms \ge immr$，则将源寄存器中从位<code>immr</code>开始的长度为($imms - immr + 1$)位的位域复制到目标寄存器的最低有效位。</li>
<li>如果$imms \lt immr$，则将源寄存器的最低有效位中长度为($imms + 1$)位的位域复制到目标寄存器的位位置($regsize - immr$)处，其中<code>regsize</code>是目标寄存器的大小，可以是$32$位或$64$位。</li>
<li>在这两种情况下，位域下方和上方的目标位都设置为零。</li>
</ul>
<p><img src="https://hexo-pirctures.oss-cn-chengdu.aliyuncs.com/imgs202407161610214.png" alt="UBFM"></p>
<p><code>UBFM</code>的使用场景通常为：</p>
<ul>
<li>位字段操作：从一个寄存器中提取特定的位字段，并将其复制到另一个寄存器中，以进行后续的处理或使用。</li>
<li>数据解析：当处理二进制数据时，可以使用 UBFM 指令来提取特定的位字段，并将其转换为有意义的数值或状态。</li>
</ul>
<p>该指令可用作别名指令<code>LSL(immediate)</code>、<code>LSR(immediate)</code>、<code>UBFIZ</code>、<code>UBFX</code>、<code>UXTB</code>和<code>UXTH</code>。</p>
<p><img src="https://hexo-pirctures.oss-cn-chengdu.aliyuncs.com/imgs202407161612084.png" alt="alias ubfm"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UBFM &lt;Wd&gt;, &lt;Wn&gt;, #&lt;immr&gt;, #&lt;imms&gt; ; 32-bits</span><br><span class="line">UBFM &lt;Xd&gt;, &lt;Xn&gt;, #&lt;immr&gt;, #&lt;imms&gt; ; 64-bits</span><br></pre></td></tr></table></figure>

<h4 id="Store-and-Load"><a href="#Store-and-Load" class="headerlink" title="Store and Load"></a>Store and Load</h4><h5 id="LDP"><a href="#LDP" class="headerlink" title="LDP"></a>LDP</h5><p><code>LDP</code><strong>指令通过基础寄存器值和立即偏移量计算地址，从内存中加载两个32位字或两个64位双字，并将它们写入两个寄存器中</strong>。</p>
<p>在<code>AddrMode</code>中我们提到，内存模型通常有三种：<code>Post</code>、<code>Pre</code>和<code>Signed offset</code></p>
<p><img src="https://hexo-pirctures.oss-cn-chengdu.aliyuncs.com/imgs202407161653917.png" alt="memory mode"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">; Post-index</span><br><span class="line">LDP &lt;Wt1&gt;, &lt;Wt2&gt;, [&lt;Xn|SP&gt;], #&lt;imm&gt; ; 32-bits, when opc == 00 </span><br><span class="line">LDP &lt;Xt1&gt;, &lt;Xt2&gt;, [&lt;Xn|SP&gt;], #&lt;imm&gt; ; 64-bits, when opc == 10 </span><br><span class="line"></span><br><span class="line">; Pre-index</span><br><span class="line">LDP &lt;Wt1&gt;, &lt;Wt2&gt;, [&lt;Xn|SP&gt;, #&lt;imm&gt;]! ; 32-bits, when opc == 00 </span><br><span class="line">LDP &lt;Xt1&gt;, &lt;Xt2&gt;, [&lt;Xn|SP&gt;, #&lt;imm&gt;]! ; 64-bits, when opc == 10 </span><br><span class="line"></span><br><span class="line">; Signed offset</span><br><span class="line">LDP &lt;Wt1&gt;, &lt;Wt2&gt;, [&lt;Xn|SP&gt;&#123;, #&lt;imm&gt;&#125;] ; 32-bits, when opc == 00 </span><br><span class="line">LDP &lt;Xt1&gt;, &lt;Xt2&gt;, [&lt;Xn|SP&gt;&#123;, #&lt;imm&gt;&#125;] ; 64-bits, when opc == 10</span><br></pre></td></tr></table></figure>

<p>对于<code>&lt;imm&gt;</code>有以下的解释：</p>
<ul>
<li>对于32位<code>Post-index</code>和32位<code>Pre-index</code>变体：有符号的立即字节偏移量在范围$-256 ~ 252$之间，是<code>4</code>的倍数，并在<code>imm7</code>字段中编码为$imm&#x2F;4$。</li>
<li>对于32位<code>Signed offset</code>变体：可选的有符号立即字节偏移量在范围$-256 ~ 252$之间，是<code>4</code>的倍数，默认为<code>0</code>，并在<code>imm7</code>字段中编码为$imm&#x2F;4$。</li>
<li>对于64位<code>Post-index</code>和64位<code>Pre-index</code>变体：有符号的立即字节偏移量在范围$-512 ~ 504$之间，是<code>8</code>的倍数，并在<code>imm7</code>字段中编码为$imm&#x2F;8$。</li>
<li>对于64位<code>Signed offset</code>变体：可选的有符号立即字节偏移量在范围$-512 ~ 504$之间，是<code>8</code>的倍数，默认为<code>0</code>，并在<code>imm7</code>字段中编码为$imm&#x2F;8$。</li>
</ul>
<p>而在实际的代码处理中，也能够很好的体现上面所说的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">LoadStorePairOpCode</span> &#123;</span><br><span class="line">    LDP_Post     = <span class="number">0x28c00000</span>,</span><br><span class="line">    LDP_Pre      = <span class="number">0x29c00000</span>,</span><br><span class="line">    LDP_Offset   = <span class="number">0x29400000</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sf) &#123;</span><br><span class="line">    imm &gt;&gt;= <span class="number">3</span>;  <span class="comment">// 3: 64 RegSise, imm/8 to remove trailing zeros</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    imm &gt;&gt;= <span class="number">2</span>;  <span class="comment">// 2: 32 RegSise, imm/4 to remove trailing zeros</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Vector-LDP"><a href="#Vector-LDP" class="headerlink" title="Vector LDP"></a>Vector LDP</h5><p><code>LDP(SIMD&amp;FP)</code><strong>指令从内存中加载一对<code>SIMD&amp;FP</code>寄存器。用于加载的地址是根据基础寄存器值和可选的立即偏移量计算得出的</strong>。</p>
<p>根据<code>CPACR_EL1</code>、<code>CPTR_EL2</code>和<code>CPTR_EL3</code>寄存器中的设置以及当前的安全状态和异常级别，执行该指令的尝试可能会被捕获。</p>
<p><img src="https://hexo-pirctures.oss-cn-chengdu.aliyuncs.com/imgs202407161713110.png" alt="ldp simd"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">; Post-index</span><br><span class="line">LDP &lt;St1&gt;, &lt;St2&gt;, [&lt;Xn|SP&gt;], #&lt;imm&gt;   ; 32-bits, when opc == 00(S)</span><br><span class="line">LDP &lt;Dt1&gt;, &lt;Dt2&gt;, [&lt;Xn|SP&gt;], #&lt;imm&gt;   ; 64-bits, when opc == 01(D)</span><br><span class="line">LDP &lt;Qt1&gt;, &lt;Qt2&gt;, [&lt;Xn|SP&gt;], #&lt;imm&gt;   ; 128-bits, when opc == 10(Q)</span><br><span class="line"></span><br><span class="line">; Pre-index</span><br><span class="line">LDP &lt;St1&gt;, &lt;St2&gt;, [&lt;Xn|SP&gt;, #&lt;imm&gt;]!  ; 32-bits, when opc == 00(S)</span><br><span class="line">LDP &lt;Dt1&gt;, &lt;Dt2&gt;, [&lt;Xn|SP&gt;, #&lt;imm&gt;]!  ; 64-bits, when opc == 01(D)</span><br><span class="line">LDP &lt;Qt1&gt;, &lt;Qt2&gt;, [&lt;Xn|SP&gt;, #&lt;imm&gt;]!  ; 128-bits, when opc == 10(Q)</span><br><span class="line"></span><br><span class="line">; Signed offset</span><br><span class="line">LDP &lt;St1&gt;, &lt;St2&gt;, [&lt;Xn|SP&gt;&#123;, #&lt;imm&gt;&#125;] ; 32-bits, when opc == 00(S)</span><br><span class="line">LDP &lt;Dt1&gt;, &lt;Dt2&gt;, [&lt;Xn|SP&gt;&#123;, #&lt;imm&gt;&#125;] ; 64-bits, when opc == 01(D)</span><br><span class="line">LDP &lt;Qt1&gt;, &lt;Qt2&gt;, [&lt;Xn|SP&gt;&#123;, #&lt;imm&gt;&#125;] ; 128-bits, when opc == 10(Q)</span><br></pre></td></tr></table></figure>

<p>对于<code>&lt;imm&gt;</code>有以下解释：</p>
<ul>
<li>对于32位<code>Post-index</code>和32位<code>Pre-index</code>变体：有符号的立即字节偏移量在范围$-256 ~ 252$之间，是<code>4</code>的倍数，并在<code>imm7</code>字段中编码为$imm &#x2F; 4$。</li>
<li>对于32位<code>Signed offset</code>变体：可选的有符号立即字节偏移量在范围$-256 ~ 252$之间，是<code>4</code>的倍数，默认为<code>0</code>，并在<code>imm7</code>字段中编码为$imm &#x2F; 4$。</li>
<li>对于64位<code>Post-index</code>和64位<code>Pre-index</code>变体：有符号的立即字节偏移量在范围$-512 ~ 504$之间，是<code>8</code>的倍数，并在<code>imm7</code>字段中编码为$imm &#x2F; 8$。</li>
<li>对于64位<code>Signed offset</code>变体：可选的有符号立即字节偏移量在范围$-512 ~ 504$之间，是<code>8</code>的倍数，默认为<code>0</code>，并在<code>imm7</code>字段中编码为$imm &#x2F; 8$。</li>
<li>对于128位<code>Post-index</code>和128位<code>Pre-index</code>变体：有符号的立即字节偏移量在范围$-1024 ~ 1008$之间，是<code>16</code>的倍数，并在<code>imm7</code>字段中编码为$imm &#x2F; 16$。</li>
<li>对于128位<code>Signed offset</code>变体：可选的有符号立即字节偏移量在范围$-1024 ~ 1008$之间，是<code>16</code>的倍数，默认为<code>0</code>，并在<code>imm7</code>字段中编码为$imm &#x2F; 16$。</li>
</ul>
<p>其具体视线中，也能够体现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (vt.<span class="built_in">GetScale</span>()) &#123;</span><br><span class="line">    <span class="keyword">case</span> S:</span><br><span class="line">        <span class="comment">// 2 : 2 means remove trailing zeros</span></span><br><span class="line">        imm &gt;&gt;= <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> D:</span><br><span class="line">        <span class="comment">// 3 : 3 means remove trailing zeros</span></span><br><span class="line">        imm &gt;&gt;= <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Q:</span><br><span class="line">        <span class="comment">// 4 : 4 means remove trailing zeros</span></span><br><span class="line">        imm &gt;&gt;= <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">LOG_ECMA</span>(FATAL) &lt;&lt; <span class="string">&quot;this branch is unreachable&quot;</span>;</span><br><span class="line">        <span class="built_in">UNREACHABLE</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="LDR-immediate"><a href="#LDR-immediate" class="headerlink" title="LDR(immediate)"></a>LDR(immediate)</h5><p><code>LDR(immediate)</code><strong>指令从内存中加载一个字或双字，并将其写入一个寄存器。用于加载的地址是根据基础寄存器和立即偏移量计算得出的。无符号偏移量变体会将立即偏移量的值按照所访问值的大小进行缩放，然后再将其加到基础寄存器值上</strong>。</p>
<p><img src="https://hexo-pirctures.oss-cn-chengdu.aliyuncs.com/imgs202407161730888.png" alt="ldr immediate"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">; Post-index</span><br><span class="line">LDR &lt;Wt&gt;, [&lt;Xn|SP&gt;], #&lt;simm&gt;    ; 32-bits, when size == 10 </span><br><span class="line">LDR &lt;Xt&gt;, [&lt;Xn|SP&gt;], #&lt;simm&gt;    ; 64-bits, when size == 11</span><br><span class="line"></span><br><span class="line">; Pre-index</span><br><span class="line">LDR &lt;Wt&gt;, [&lt;Xn|SP&gt;, #&lt;simm&gt;]!   ; 32-bits, when size == 10</span><br><span class="line">LDR &lt;Xt&gt;, [&lt;Xn|SP&gt;, #&lt;simm&gt;]!   ; 64-bits, when size == 11</span><br><span class="line"></span><br><span class="line">; Signed offset</span><br><span class="line">LDR &lt;Wt&gt;, [&lt;Xn|SP&gt;&#123;, #&lt;pimm&gt;&#125;]  ; 32-bits, when size == 10</span><br><span class="line">LDR &lt;Xt&gt;, [&lt;Xn|SP&gt;&#123;, #&lt;pimm&gt;&#125;]  ; 64-bits, when size == 11 </span><br></pre></td></tr></table></figure>

<p>实际中，我们在<code>Ldr</code>函数中共同处理了两种情况，这里给出<code>ldr(immediate)</code>的处理逻辑：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (operand.<span class="built_in">IsImmediateOffset</span>()) &#123;</span><br><span class="line">    <span class="type">uint64_t</span> imm = <span class="built_in">GetImmOfLdr</span>(operand, scale, regX);</span><br><span class="line">    <span class="type">bool</span> isSigned = operand.<span class="built_in">GetAddrMode</span>() != AddrMode::OFFSET;</span><br><span class="line">    <span class="comment">// 30: 30bit indicate the size of LDR Reg, and Ldrb and Ldrh do not need it</span></span><br><span class="line">    <span class="type">uint32_t</span> instructionCode = ((regX &amp;&amp; (scale == Scale::Q)) &lt;&lt; <span class="number">30</span>) | op | <span class="built_in">LoadAndStoreImm</span>(imm, isSigned) |</span><br><span class="line">                                <span class="built_in">Rn</span>(operand.<span class="built_in">GetRegBase</span>().<span class="built_in">GetId</span>()) | <span class="built_in">Rt</span>(rt.<span class="built_in">GetId</span>());</span><br><span class="line">    <span class="built_in">EmitU32</span>(instructionCode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="LDR-register"><a href="#LDR-register" class="headerlink" title="LDR(register)"></a>LDR(register)</h5><p><code>LDR(register)</code><strong>指令根据基础寄存器值和偏移寄存器值计算一个地址，从内存中加载一个字，并将其写入一个寄存器。偏移寄存器值可以选择进行位移和扩展操作</strong>。</p>
<p><img src="https://hexo-pirctures.oss-cn-chengdu.aliyuncs.com/imgs202407161747916.png" alt="ldr register"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LDR &lt;Wt&gt;, [&lt;Xn|SP&gt;, (&lt;Wm&gt;|&lt;Xm&gt;)&#123;, &lt;extend&gt; &#123;&lt;amount&gt;&#125;&#125;] ; 32-bits, when size == 10 </span><br><span class="line">LDR &lt;Xt&gt;, [&lt;Xn|SP&gt;, (&lt;Wm&gt;|&lt;Xm&gt;)&#123;, &lt;extend&gt; &#123;&lt;amount&gt;&#125;&#125;] ; 64-bits, when size == 11</span><br></pre></td></tr></table></figure>

<p><code>&lt;extend&gt;</code>是索引扩展&#x2F;位移说明符(<code>index extend/shift specifier</code>），默认为<code>LSL(左移)</code>。当<code>&lt;amount&gt;</code>被省略时，必须为<code>LSL</code>省略<code>&lt;extend&gt;</code>。其解码为<code>option</code>字段。它可以具有以下值:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UXTW    when option = 010</span><br><span class="line">LSL     when option = 011</span><br><span class="line">SXTW    when option = 110</span><br><span class="line">SXTX    when option = 111</span><br></pre></td></tr></table></figure>

<p><code>&lt;amount&gt;</code>是唯一索引量，当<code>&lt;extend&gt;</code>不为<code>LSL</code>时可选。当允许被选中时，其默认值为<code>0</code>，被解码为<code>S</code>字段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">; 32-bits</span><br><span class="line">#0 when S = 0</span><br><span class="line">#2 when S = 1</span><br><span class="line"></span><br><span class="line">; 64-bits</span><br><span class="line">#0 when S = 0</span><br><span class="line">#3 when S = 1</span><br></pre></td></tr></table></figure>

<h5 id="LDRB-immediate"><a href="#LDRB-immediate" class="headerlink" title="LDRB(immediate)"></a>LDRB(immediate)</h5><p><code>LDRB(immediate)</code><strong>从内存中加载一个字节，对其进行零扩展，并将结果写入寄存器。用于加载的地址是从基寄存器和立即偏移量计算出来的</strong>。</p>
<p><img src="https://hexo-pirctures.oss-cn-chengdu.aliyuncs.com/imgs202407161800512.png" alt="ldrb immediate"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">; Post-index</span><br><span class="line">LDRB &lt;Wt&gt;, [&lt;Xn|SP&gt;], #&lt;simm&gt;</span><br><span class="line"></span><br><span class="line">; Pre-index</span><br><span class="line">LDRB &lt;Wt&gt;, [&lt;Xn|SP&gt;, #&lt;simm&gt;]!</span><br><span class="line"></span><br><span class="line">; Signed offset</span><br><span class="line">LDRB &lt;Wt&gt;, [&lt;Xn|SP&gt;&#123;, #&lt;pimm&gt;&#125;]</span><br></pre></td></tr></table></figure>

<p>对于<code>LDRB</code>的具体实现，直接通过<code>LDR</code>进行实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AssemblerAarch64::Ldrb</span><span class="params">(<span class="type">const</span> Register &amp;rt, <span class="type">const</span> MemoryOperand &amp;operand)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ASSERT</span>(rt.<span class="built_in">IsW</span>());</span><br><span class="line">    <span class="built_in">Ldr</span>(rt, operand, Scale::B);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="LDRB-register"><a href="#LDRB-register" class="headerlink" title="LDRB(register)"></a>LDRB(register)</h5><p><code>LDRB(register)</code><strong>从基寄存器值和偏移寄存器值计算一个地址，从内存中加载一个字节，对其进行零扩展，并将其写入寄存器</strong>。</p>
<p><img src="https://hexo-pirctures.oss-cn-chengdu.aliyuncs.com/imgs202407161802805.png" alt="ldrb regsiter"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">; Extended register </span><br><span class="line">LDRB &lt;Wt&gt;, [&lt;Xn|SP&gt;, (&lt;Wm&gt;|&lt;Xm&gt;), &lt;extend&gt; &#123;&lt;amount&gt;&#125;]  ; when option != 011 .</span><br><span class="line"></span><br><span class="line">; Shifted register</span><br><span class="line">LDRB &lt;Wt&gt;, [&lt;Xn|SP&gt;, &lt;Xm&gt;&#123;, LSL &lt;amount&gt;&#125;]  ; when option == 011 </span><br></pre></td></tr></table></figure>

<h5 id="LDRH-immediate"><a href="#LDRH-immediate" class="headerlink" title="LDRH(immediate)"></a>LDRH(immediate)</h5><p><code>LDRH(immediate)</code><strong>从内存中加载半字，对其进行零扩展，并将结果写入寄存器。用于加载的地址是从基寄存器和立即偏移量计算出来的</strong>。</p>
<p><img src="https://hexo-pirctures.oss-cn-chengdu.aliyuncs.com/imgs202407161805014.png" alt="LDRH(immediate)"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">; Post-index</span><br><span class="line">LDRH &lt;Wt&gt;, [&lt;Xn|SP&gt;], #&lt;simm&gt;</span><br><span class="line"></span><br><span class="line">; Pre-index</span><br><span class="line">LDRH &lt;Wt&gt;, [&lt;Xn|SP&gt;, #&lt;simm&gt;]!</span><br><span class="line"></span><br><span class="line">; Unsigned offset</span><br><span class="line">LDRH &lt;Wt&gt;, [&lt;Xn|SP&gt;&#123;, #&lt;pimm&gt;&#125;]</span><br></pre></td></tr></table></figure>

<p>其内部实现由<code>LDR</code>构成：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AssemblerAarch64::Ldrh</span><span class="params">(<span class="type">const</span> Register &amp;rt, <span class="type">const</span> MemoryOperand &amp;operand)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ASSERT</span>(rt.<span class="built_in">IsW</span>());</span><br><span class="line">    <span class="built_in">Ldr</span>(rt, operand, Scale::H);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="LDRH-register"><a href="#LDRH-register" class="headerlink" title="LDRH(register)"></a>LDRH(register)</h5><p><code>LDRH(register)</code><strong>从基寄存器值和偏移寄存器值计算地址，从内存中加载半字，对其进行零扩展，并将其写入寄存器</strong>。</p>
<p><img src="https://hexo-pirctures.oss-cn-chengdu.aliyuncs.com/imgs202407161807499.png" alt="LDRH register"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LDRH &lt;Wt&gt;, [&lt;Xn|SP&gt;, (&lt;Wm&gt;|&lt;Xm&gt;)&#123;, &lt;extend&gt; &#123;&lt;amount&gt;&#125;&#125;]</span><br></pre></td></tr></table></figure>

<h5 id="LDUR"><a href="#LDUR" class="headerlink" title="LDUR"></a>LDUR</h5><p><code>LDUR</code><strong>从基寄存器和直接偏移量中计算一个地址，从内存中加载一个32位字或64位双字，对其进行零扩展，并将其写入寄存器</strong>。</p>
<p><img src="https://hexo-pirctures.oss-cn-chengdu.aliyuncs.com/imgs202407161809487.png" alt="ldur"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LDUR &lt;Wt&gt;, [&lt;Xn|SP&gt;&#123;, #&lt;simm&gt;&#125;]   ; 32-bits, when size == 10</span><br><span class="line">LDUR &lt;Xt&gt;, [&lt;Xn|SP&gt;&#123;, #&lt;simm&gt;&#125;]   ; 64-bits, when size == 11</span><br></pre></td></tr></table></figure>

<p>其具体实现为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AssemblerAarch64::Ldur</span><span class="params">(<span class="type">const</span> Register &amp;rt, <span class="type">const</span> MemoryOperand &amp;operand)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> regX = !rt.<span class="built_in">IsW</span>();</span><br><span class="line">    <span class="type">uint32_t</span> op = LDUR_Offset;</span><br><span class="line">    <span class="built_in">ASSERT</span>(operand.<span class="built_in">IsImmediateOffset</span>());</span><br><span class="line">    <span class="type">uint64_t</span> imm = <span class="built_in">static_cast</span>&lt;<span class="type">uint64_t</span>&gt;(operand.<span class="built_in">GetImmediate</span>().<span class="built_in">Value</span>());</span><br><span class="line">    <span class="comment">// 30: 30bit indicate the size of LDUR Reg</span></span><br><span class="line">    <span class="type">uint32_t</span> instructionCode = (regX &lt;&lt; <span class="number">30</span>) | op | <span class="built_in">LoadAndStoreImm</span>(imm, <span class="literal">true</span>) |</span><br><span class="line">                               <span class="built_in">Rn</span>(operand.<span class="built_in">GetRegBase</span>().<span class="built_in">GetId</span>()) | <span class="built_in">Rt</span>(rt.<span class="built_in">GetId</span>());</span><br><span class="line">    <span class="built_in">EmitU32</span>(instructionCode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="STP"><a href="#STP" class="headerlink" title="STP"></a>STP</h5><p><code>STP</code><strong>从基寄存器值和直接偏移量计算地址，并从两个寄存器中存储两个32位字或两个64位双字到计算的地址</strong>。</p>
<p><img src="https://hexo-pirctures.oss-cn-chengdu.aliyuncs.com/imgs202407161818457.png" alt="stp"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">; Post-index</span><br><span class="line">STP &lt;Wt1&gt;, &lt;Wt2&gt;, [&lt;Xn|SP&gt;], #&lt;imm&gt;   ; 32-bits, when opc == 00 </span><br><span class="line">STP &lt;Xt1&gt;, &lt;Xt2&gt;, [&lt;Xn|SP&gt;], #&lt;imm&gt;   ; 64-bits, when opc == 01</span><br><span class="line"></span><br><span class="line">; Pre-index</span><br><span class="line">STP &lt;Wt1&gt;, &lt;Wt2&gt;, [&lt;Xn|SP&gt;, #&lt;imm&gt;]!   ; 32-bits, when opc == 00 </span><br><span class="line">STP &lt;Xt1&gt;, &lt;Xt2&gt;, [&lt;Xn|SP&gt;, #&lt;imm&gt;]!   ; 64-bits, when opc == 01</span><br><span class="line"></span><br><span class="line">; Signed offset</span><br><span class="line">STP &lt;Wt1&gt;, &lt;Wt2&gt;, [&lt;Xn|SP&gt;&#123;, #&lt;imm&gt;&#125;]   ; 32-bits, when opc == 00 </span><br><span class="line">STP &lt;Xt1&gt;, &lt;Xt2&gt;, [&lt;Xn|SP&gt;&#123;, #&lt;imm&gt;&#125;]   ; 64-bits, when opc == 01</span><br></pre></td></tr></table></figure>

<p>对于<code>STP</code>的实际实现，主要代码片段为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> OFFSET:</span><br><span class="line">    op = LoadStorePairOpCode::STP_Offset;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> PREINDEX:</span><br><span class="line">    op = LoadStorePairOpCode::STP_Pre;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> POSTINDEX:</span><br><span class="line">    op = LoadStorePairOpCode::STP_Post;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> (sf) &#123;</span><br><span class="line">    imm &gt;&gt;= <span class="number">3</span>;  <span class="comment">// 3: 64 RegSise, imm/8 to remove trailing zeros</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    imm &gt;&gt;= <span class="number">2</span>;  <span class="comment">// 2: 32 RegSise, imm/4 to remove trailing zeros</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Vector-STP"><a href="#Vector-STP" class="headerlink" title="Vector STP"></a>Vector STP</h5><p><code>STP(SIMD&amp;FP)</code><strong>将一对<code>SIMD&amp;FP</code>寄存器存储到内存中。用于存储的地址是从基寄存器值和立即偏移量计算出来的</strong>。</p>
<p>根据<code>CPACR_EL1</code>、<code>CPTR_EL2</code>和<code>CPTR_EL3</code>寄存器中的设置，以及当前的安全状态和Exception级别，执行指令的尝试可能会被捕获。</p>
<p><img src="https://hexo-pirctures.oss-cn-chengdu.aliyuncs.com/imgs202407161822544.png" alt="stp(simd&amp;fp)"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">; Post-index</span><br><span class="line">STP &lt;St1&gt;, &lt;St2&gt;, [&lt;Xn|SP&gt;], #&lt;imm&gt;   ; 32-bits, when opc == 00(S)</span><br><span class="line">STP &lt;Dt1&gt;, &lt;Dt2&gt;, [&lt;Xn|SP&gt;], #&lt;imm&gt;   ; 64-bits, when opc == 01(D)</span><br><span class="line">STP &lt;Qt1&gt;, &lt;Qt2&gt;, [&lt;Xn|SP&gt;], #&lt;imm&gt;   ; 128-bits, when opc == 10(Q)</span><br><span class="line"></span><br><span class="line">; Pre-index</span><br><span class="line">STP &lt;St1&gt;, &lt;St2&gt;, [&lt;Xn|SP&gt;, #&lt;imm&gt;]!   ; 32-bits, when opc == 00(S)</span><br><span class="line">STP &lt;Dt1&gt;, &lt;Dt2&gt;, [&lt;Xn|SP&gt;, #&lt;imm&gt;]!   ; 64-bits, when opc == 01(D)</span><br><span class="line">STP &lt;Qt1&gt;, &lt;Qt2&gt;, [&lt;Xn|SP&gt;, #&lt;imm&gt;]!   ; 128-bits, when opc == 10(Q)</span><br><span class="line"></span><br><span class="line">; Signed offset</span><br><span class="line">STP &lt;St1&gt;, &lt;St2&gt;, [&lt;Xn|SP&gt;&#123;, #&lt;imm&gt;&#125;]   ; 32-bits, when opc == 00(S)</span><br><span class="line">STP &lt;Dt1&gt;, &lt;Dt2&gt;, [&lt;Xn|SP&gt;&#123;, #&lt;imm&gt;&#125;]   ; 64-bits, when opc == 01(D)</span><br><span class="line">STP &lt;Qt1&gt;, &lt;Qt2&gt;, [&lt;Xn|SP&gt;&#123;, #&lt;imm&gt;&#125;]   ; 128-bits, when opc == 10(Q)</span><br></pre></td></tr></table></figure>

<p>其代码的主要部分为:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> OFFSET:</span><br><span class="line">    op = LoadStorePairOpCode::STP_V_Offset;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> PREINDEX:</span><br><span class="line">    op = LoadStorePairOpCode::STP_V_Pre;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> POSTINDEX:</span><br><span class="line">    op = LoadStorePairOpCode::STP_V_Post;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> S:</span><br><span class="line">    <span class="comment">// 2 : 2 means remove trailing zeros</span></span><br><span class="line">    imm &gt;&gt;= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> D:</span><br><span class="line">    <span class="comment">// 3 : 3 means remove trailing zeros</span></span><br><span class="line">    imm &gt;&gt;= <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> Q:</span><br><span class="line">    <span class="comment">// 4 : 4 means remove trailing zeros</span></span><br><span class="line">    imm &gt;&gt;= <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<h5 id="STR"><a href="#STR" class="headerlink" title="STR"></a>STR</h5><p><code>STR</code><strong>将一个字或双字从寄存器存储到存储器中。用于存储的地址是从基寄存器和立即偏移量计算出来的</strong>。</p>
<p><img src="https://hexo-pirctures.oss-cn-chengdu.aliyuncs.com/imgs202407161931064.png" alt="str immediate"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">; Post-index</span><br><span class="line">STR &lt;Wt&gt;, [&lt;Xn|SP&gt;], #&lt;simm&gt;    ; 32-bits, when size == 10</span><br><span class="line">STR &lt;Xt&gt;, [&lt;Xn|SP&gt;], #&lt;simm&gt;    ; 64-bits, when size == 11</span><br><span class="line"></span><br><span class="line">; Pre-index</span><br><span class="line">STR &lt;Wt&gt;, [&lt;Xn|SP&gt;, #&lt;simm&gt;]!   ; 32-bits, when size == 10</span><br><span class="line">STR &lt;Xt&gt;, [&lt;Xn|SP&gt;, #&lt;simm&gt;]!   ; 64-bits, when size == 11</span><br><span class="line"></span><br><span class="line">; Unsigned offset</span><br><span class="line">STR &lt;Wt&gt;, [&lt;Xn|SP&gt;&#123;, #&lt;pimm&gt;&#125;]  ; 32-bits, when size == 10</span><br><span class="line">STR &lt;Xt&gt;, [&lt;Xn|SP&gt;&#123;, #&lt;pimm&gt;&#125;]  ; 64-bits, when size == 11</span><br></pre></td></tr></table></figure>

<p>在<code>ArkTS</code>中，主要实现了<code>str(immediate)</code>其内部的主要实现为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> OFFSET:</span><br><span class="line">    op = LoadStoreOpCode::STR_Offset;</span><br><span class="line">    <span class="keyword">if</span> (regX) &#123;</span><br><span class="line">        imm &gt;&gt;= <span class="number">3</span>;   <span class="comment">// 3:  64 RegSise, imm/8 to remove trailing zeros</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        imm &gt;&gt;= <span class="number">2</span>;  <span class="comment">// 2: 32 RegSise, imm/4 to remove trailing zeros</span></span><br><span class="line">    &#125;</span><br><span class="line">    isSigned = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> PREINDEX:</span><br><span class="line">    op = LoadStoreOpCode::STR_Pre;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> POSTINDEX:</span><br><span class="line">    op = LoadStoreOpCode::STR_Post;</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<h5 id="STUR"><a href="#STUR" class="headerlink" title="STUR"></a>STUR</h5><p><code>STUR</code><strong>从基本寄存器值和直接偏移量计算一个地址，并从寄存器中存储一个32位字或64位双字到计算出的地址</strong>。</p>
<p><img src="https://hexo-pirctures.oss-cn-chengdu.aliyuncs.com/imgs202407161935126.png" alt="stur"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">STUR &lt;Wt&gt;, [&lt;Xn|SP&gt;&#123;, #&lt;simm&gt;&#125;]   ; 32-bits, when size == 10</span><br><span class="line">STUR &lt;Xt&gt;, [&lt;Xn|SP&gt;&#123;, #&lt;simm&gt;&#125;]   ; 64-bits, when size == 11</span><br></pre></td></tr></table></figure>

<p>其内部实现为:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AssemblerAarch64::Ldur</span><span class="params">(<span class="type">const</span> Register &amp;rt, <span class="type">const</span> MemoryOperand &amp;operand)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> regX = !rt.<span class="built_in">IsW</span>();</span><br><span class="line">    <span class="type">uint32_t</span> op = LDUR_Offset;</span><br><span class="line">    <span class="built_in">ASSERT</span>(operand.<span class="built_in">IsImmediateOffset</span>());</span><br><span class="line">    <span class="type">uint64_t</span> imm = <span class="built_in">static_cast</span>&lt;<span class="type">uint64_t</span>&gt;(operand.<span class="built_in">GetImmediate</span>().<span class="built_in">Value</span>());</span><br><span class="line">    <span class="comment">// 30: 30bit indicate the size of LDUR Reg</span></span><br><span class="line">    <span class="type">uint32_t</span> instructionCode = (regX &lt;&lt; <span class="number">30</span>) | op | <span class="built_in">LoadAndStoreImm</span>(imm, <span class="literal">true</span>) |</span><br><span class="line">                               <span class="built_in">Rn</span>(operand.<span class="built_in">GetRegBase</span>().<span class="built_in">GetId</span>()) | <span class="built_in">Rt</span>(rt.<span class="built_in">GetId</span>());</span><br><span class="line">    <span class="built_in">EmitU32</span>(instructionCode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>至此，<code>ArkTS</code>的<code>Aarch</code>汇编的分析到此结束了。</p>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>Chen Miao</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="https://chenmiaoi.github.io/2024/07/04/ArkTS-analyze-compiler-assember/">https://chenmiaoi.github.io/2024/07/04/ArkTS-analyze-compiler-assember/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2024 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>Do you believe in <strong>DESTINY</strong>?</span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/arkts/"># arkts</a>
                    
                        <a href="/tags/ospp/"># ospp</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2024/07/16/ArkTS-analyze-riscv64-assember/">ArkTS: Analyze Riscv64 Assember</a>
            
            
            <a class="next" rel="next" href="/2024/07/01/ArkTS-compile-runtime-core-and-ets/">ArkTS: Compile Runtime_core and Ets_*</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Chen Miao | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>